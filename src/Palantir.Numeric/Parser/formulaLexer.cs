//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 formula.g 2016-04-14 15:03:08

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

namespace Palantir.Numeric.Parser
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class formulaLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int CURRENCY=4;
	public const int CURR_AFN=5;
	public const int CURR_ALL=6;
	public const int CURR_AWG=7;
	public const int CURR_AZN=8;
	public const int CURR_BAM=9;
	public const int CURR_BGN=10;
	public const int CURR_BOB=11;
	public const int CURR_BRL=12;
	public const int CURR_BWP=13;
	public const int CURR_BYR=14;
	public const int CURR_BZD=15;
	public const int CURR_CHF=16;
	public const int CURR_CRC=17;
	public const int CURR_CUP=18;
	public const int CURR_CZK=19;
	public const int CURR_DKK=20;
	public const int CURR_DOP=21;
	public const int CURR_EUR=22;
	public const int CURR_GBP=23;
	public const int CURR_GHS=24;
	public const int CURR_GTQ=25;
	public const int CURR_HNL=26;
	public const int CURR_HRK=27;
	public const int CURR_HUF=28;
	public const int CURR_IDR=29;
	public const int CURR_ILS=30;
	public const int CURR_IRR=31;
	public const int CURR_JMD=32;
	public const int CURR_JPY=33;
	public const int CURR_KHR=34;
	public const int CURR_KPW=35;
	public const int CURR_LAK=36;
	public const int CURR_MKD=37;
	public const int CURR_MNT=38;
	public const int CURR_MUR=39;
	public const int CURR_MYR=40;
	public const int CURR_MZN=41;
	public const int CURR_NGN=42;
	public const int CURR_NIO=43;
	public const int CURR_PAB=44;
	public const int CURR_PEN=45;
	public const int CURR_PLN=46;
	public const int CURR_PYG=47;
	public const int CURR_RON=48;
	public const int CURR_RSD=49;
	public const int CURR_RUB=50;
	public const int CURR_SOS=51;
	public const int CURR_SYM=52;
	public const int CURR_THB=53;
	public const int CURR_TTD=54;
	public const int CURR_TWD=55;
	public const int CURR_UAH=56;
	public const int CURR_USD=57;
	public const int CURR_UYU=58;
	public const int CURR_VEF=59;
	public const int CURR_VND=60;
	public const int CURR_XBT=61;
	public const int CURR_ZAR=62;
	public const int CURR_ZWD=63;
	public const int DIGIT=64;
	public const int DIV=65;
	public const int EXP=66;
	public const int FLOAT=67;
	public const int HEX_DIGIT=68;
	public const int INTEGER=69;
	public const int MINUS=70;
	public const int MULT=71;
	public const int OCTAL_DIGIT=72;
	public const int PLUS=73;
	public const int POW=74;
	public const int POW_DIGIT=75;
	public const int SI_AMP=76;
	public const int SI_AMP_METER=77;
	public const int SI_AMP_SQ_METER_1=78;
	public const int SI_AMP_SQ_METER_2=79;
	public const int SI_BECQUEREL=80;
	public const int SI_CANDELA=81;
	public const int SI_CANDELA_SQ_METER_1=82;
	public const int SI_CANDELA_SQ_METER_2=83;
	public const int SI_CELCIUS=84;
	public const int SI_COULOMB=85;
	public const int SI_COULOMB_PER_CU_METER_1=86;
	public const int SI_COULOMB_PER_CU_METER_2=87;
	public const int SI_COULOMB_PER_KG=88;
	public const int SI_COULOMB_PER_SQ_METER_1=89;
	public const int SI_COULOMB_PER_SQ_METER_2=90;
	public const int SI_CU_METER_1=91;
	public const int SI_CU_METER_2=92;
	public const int SI_CU_METER_KG_1=93;
	public const int SI_CU_METER_KG_2=94;
	public const int SI_FARAD=95;
	public const int SI_FARAD_PER_METER=96;
	public const int SI_GRAY=97;
	public const int SI_GRAY_PER_SEC=98;
	public const int SI_HENRY=99;
	public const int SI_HENRY_PER_METER=100;
	public const int SI_HERTZ=101;
	public const int SI_JOULE=102;
	public const int SI_JOULE_PER_CU_METER_1=103;
	public const int SI_JOULE_PER_CU_METER_2=104;
	public const int SI_JOULE_PER_KELVIN=105;
	public const int SI_JOULE_PER_KG=106;
	public const int SI_JOULE_PER_KG_KELVIN=107;
	public const int SI_JOULE_PER_MOLE=108;
	public const int SI_JOULE_PER_MOLE_KELVIN=109;
	public const int SI_KATAL=110;
	public const int SI_KATAL_PER_CU_METER_1=111;
	public const int SI_KATAL_PER_CU_METER_2=112;
	public const int SI_KELVIN=113;
	public const int SI_KG=114;
	public const int SI_KG_CU_METER_1=115;
	public const int SI_KG_CU_METER_2=116;
	public const int SI_LUMEN=117;
	public const int SI_LUX=118;
	public const int SI_METER=119;
	public const int SI_MOLE=120;
	public const int SI_MOL_CU_METER_1=121;
	public const int SI_MOL_CU_METER_2=122;
	public const int SI_MPS=123;
	public const int SI_MPS_SQ_1=124;
	public const int SI_MPS_SQ_2=125;
	public const int SI_NEWTON=126;
	public const int SI_NEWTON_METER=127;
	public const int SI_NEWTON_PER_METER=128;
	public const int SI_OHM_1=129;
	public const int SI_OHM_2=130;
	public const int SI_PASCAL=131;
	public const int SI_PASCAL_SEC=132;
	public const int SI_RADIAN=133;
	public const int SI_RADIAN_PER_SEC=134;
	public const int SI_RADIAN_PER_SEC_SQ_1=135;
	public const int SI_RADIAN_PER_SEC_SQ_2=136;
	public const int SI_REC_METER_1=137;
	public const int SI_REC_METER_2=138;
	public const int SI_SEC=139;
	public const int SI_SIEMENS=140;
	public const int SI_SIEVERT=141;
	public const int SI_SOLID_ANGLE=142;
	public const int SI_SQ_METER_1=143;
	public const int SI_SQ_METER_2=144;
	public const int SI_TESLA=145;
	public const int SI_UNIT=146;
	public const int SI_VOLT=147;
	public const int SI_VOLT_PER_METER=148;
	public const int SI_WATT=149;
	public const int SI_WATT_PER_METER_KELVIN=150;
	public const int SI_WATT_PER_METER_SQ_1=151;
	public const int SI_WATT_PER_METER_SQ_2=152;
	public const int SI_WATT_PER_SQ_METER_STERADIAN_1=153;
	public const int SI_WATT_PER_SQ_METER_STERADIAN_2=154;
	public const int SI_WATT_PER_STERADIAN=155;
	public const int SI_WEBER=156;
	public const int UNIT=157;
	public const int WHITESPACE=158;

    // delegates
    // delegators

	public formulaLexer()
	{
		OnCreated();
	}

	public formulaLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public formulaLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "formula.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	partial void EnterRule_INTEGER();
	partial void LeaveRule_INTEGER();

	// $ANTLR start "INTEGER"
	[GrammarRule("INTEGER")]
	private void mINTEGER()
	{
		EnterRule_INTEGER();
		EnterRule("INTEGER", 1);
		TraceIn("INTEGER", 1);
		try
		{
			int _type = INTEGER;
			int _channel = DefaultTokenChannel;
			// formula.g:38:10: ( ( DIGIT )+ )
			DebugEnterAlt(1);
			// formula.g:38:12: ( DIGIT )+
			{
			DebugLocation(38, 12);
			// formula.g:38:12: ( DIGIT )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if (((LA1_0>='1' && LA1_0<='9')))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:38:13: DIGIT
					{
					DebugLocation(38, 13);
					mDIGIT(); 

					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("INTEGER", 1);
			LeaveRule("INTEGER", 1);
			LeaveRule_INTEGER();
		}
	}
	// $ANTLR end "INTEGER"

	partial void EnterRule_FLOAT();
	partial void LeaveRule_FLOAT();

	// $ANTLR start "FLOAT"
	[GrammarRule("FLOAT")]
	private void mFLOAT()
	{
		EnterRule_FLOAT();
		EnterRule("FLOAT", 2);
		TraceIn("FLOAT", 2);
		try
		{
			int _type = FLOAT;
			int _channel = DefaultTokenChannel;
			// formula.g:41:2: ( ( DIGIT )* '.' ( DIGIT )+ ( EXP )? | ( DIGIT )+ EXP )
			int alt6=2;
			try { DebugEnterDecision(6, false);
			try
			{
				alt6 = dfa6.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:41:4: ( DIGIT )* '.' ( DIGIT )+ ( EXP )?
				{
				DebugLocation(41, 4);
				// formula.g:41:4: ( DIGIT )*
				try { DebugEnterSubRule(2);
				while (true)
				{
					int alt2=2;
					try { DebugEnterDecision(2, false);
					int LA2_0 = input.LA(1);

					if (((LA2_0>='1' && LA2_0<='9')))
					{
						alt2 = 1;
					}


					} finally { DebugExitDecision(2); }
					switch ( alt2 )
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:41:4: DIGIT
						{
						DebugLocation(41, 4);
						mDIGIT(); 

						}
						break;

					default:
						goto loop2;
					}
				}

				loop2:
					;

				} finally { DebugExitSubRule(2); }

				DebugLocation(41, 11);
				Match('.'); 
				DebugLocation(41, 15);
				// formula.g:41:15: ( DIGIT )+
				int cnt3=0;
				try { DebugEnterSubRule(3);
				while (true)
				{
					int alt3=2;
					try { DebugEnterDecision(3, false);
					int LA3_0 = input.LA(1);

					if (((LA3_0>='1' && LA3_0<='9')))
					{
						alt3 = 1;
					}


					} finally { DebugExitDecision(3); }
					switch (alt3)
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:41:15: DIGIT
						{
						DebugLocation(41, 15);
						mDIGIT(); 

						}
						break;

					default:
						if (cnt3 >= 1)
							goto loop3;

						EarlyExitException eee3 = new EarlyExitException( 3, input );
						DebugRecognitionException(eee3);
						throw eee3;
					}
					cnt3++;
				}
				loop3:
					;

				} finally { DebugExitSubRule(3); }

				DebugLocation(41, 22);
				// formula.g:41:22: ( EXP )?
				int alt4=2;
				try { DebugEnterSubRule(4);
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0=='E'||LA4_0=='e'))
				{
					alt4 = 1;
				}
				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:41:22: EXP
					{
					DebugLocation(41, 22);
					mEXP(); 

					}
					break;

				}
				} finally { DebugExitSubRule(4); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:42:4: ( DIGIT )+ EXP
				{
				DebugLocation(42, 4);
				// formula.g:42:4: ( DIGIT )+
				int cnt5=0;
				try { DebugEnterSubRule(5);
				while (true)
				{
					int alt5=2;
					try { DebugEnterDecision(5, false);
					int LA5_0 = input.LA(1);

					if (((LA5_0>='1' && LA5_0<='9')))
					{
						alt5 = 1;
					}


					} finally { DebugExitDecision(5); }
					switch (alt5)
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:42:4: DIGIT
						{
						DebugLocation(42, 4);
						mDIGIT(); 

						}
						break;

					default:
						if (cnt5 >= 1)
							goto loop5;

						EarlyExitException eee5 = new EarlyExitException( 5, input );
						DebugRecognitionException(eee5);
						throw eee5;
					}
					cnt5++;
				}
				loop5:
					;

				} finally { DebugExitSubRule(5); }

				DebugLocation(42, 11);
				mEXP(); 

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("FLOAT", 2);
			LeaveRule("FLOAT", 2);
			LeaveRule_FLOAT();
		}
	}
	// $ANTLR end "FLOAT"

	partial void EnterRule_CURRENCY();
	partial void LeaveRule_CURRENCY();

	// $ANTLR start "CURRENCY"
	[GrammarRule("CURRENCY")]
	private void mCURRENCY()
	{
		EnterRule_CURRENCY();
		EnterRule("CURRENCY", 3);
		TraceIn("CURRENCY", 3);
		try
		{
			int _type = CURRENCY;
			int _channel = DefaultTokenChannel;
			// formula.g:46:2: ( CURR_SYM ( ' ' )? ( DIGIT )* '.' ( DIGIT )+ | CURR_SYM ( ' ' )? ( DIGIT )+ )
			int alt12=2;
			try { DebugEnterDecision(12, false);
			try
			{
				alt12 = dfa12.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(12); }
			switch (alt12)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:46:4: CURR_SYM ( ' ' )? ( DIGIT )* '.' ( DIGIT )+
				{
				DebugLocation(46, 4);
				mCURR_SYM(); 
				DebugLocation(46, 13);
				// formula.g:46:13: ( ' ' )?
				int alt7=2;
				try { DebugEnterSubRule(7);
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==' '))
				{
					alt7 = 1;
				}
				} finally { DebugExitDecision(7); }
				switch (alt7)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:46:13: ' '
					{
					DebugLocation(46, 13);
					Match(' '); 

					}
					break;

				}
				} finally { DebugExitSubRule(7); }

				DebugLocation(46, 18);
				// formula.g:46:18: ( DIGIT )*
				try { DebugEnterSubRule(8);
				while (true)
				{
					int alt8=2;
					try { DebugEnterDecision(8, false);
					int LA8_0 = input.LA(1);

					if (((LA8_0>='1' && LA8_0<='9')))
					{
						alt8 = 1;
					}


					} finally { DebugExitDecision(8); }
					switch ( alt8 )
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:46:18: DIGIT
						{
						DebugLocation(46, 18);
						mDIGIT(); 

						}
						break;

					default:
						goto loop8;
					}
				}

				loop8:
					;

				} finally { DebugExitSubRule(8); }

				DebugLocation(46, 25);
				Match('.'); 
				DebugLocation(46, 29);
				// formula.g:46:29: ( DIGIT )+
				int cnt9=0;
				try { DebugEnterSubRule(9);
				while (true)
				{
					int alt9=2;
					try { DebugEnterDecision(9, false);
					int LA9_0 = input.LA(1);

					if (((LA9_0>='1' && LA9_0<='9')))
					{
						alt9 = 1;
					}


					} finally { DebugExitDecision(9); }
					switch (alt9)
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:46:29: DIGIT
						{
						DebugLocation(46, 29);
						mDIGIT(); 

						}
						break;

					default:
						if (cnt9 >= 1)
							goto loop9;

						EarlyExitException eee9 = new EarlyExitException( 9, input );
						DebugRecognitionException(eee9);
						throw eee9;
					}
					cnt9++;
				}
				loop9:
					;

				} finally { DebugExitSubRule(9); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:47:4: CURR_SYM ( ' ' )? ( DIGIT )+
				{
				DebugLocation(47, 4);
				mCURR_SYM(); 
				DebugLocation(47, 13);
				// formula.g:47:13: ( ' ' )?
				int alt10=2;
				try { DebugEnterSubRule(10);
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==' '))
				{
					alt10 = 1;
				}
				} finally { DebugExitDecision(10); }
				switch (alt10)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:47:13: ' '
					{
					DebugLocation(47, 13);
					Match(' '); 

					}
					break;

				}
				} finally { DebugExitSubRule(10); }

				DebugLocation(47, 18);
				// formula.g:47:18: ( DIGIT )+
				int cnt11=0;
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if (((LA11_0>='1' && LA11_0<='9')))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:47:18: DIGIT
						{
						DebugLocation(47, 18);
						mDIGIT(); 

						}
						break;

					default:
						if (cnt11 >= 1)
							goto loop11;

						EarlyExitException eee11 = new EarlyExitException( 11, input );
						DebugRecognitionException(eee11);
						throw eee11;
					}
					cnt11++;
				}
				loop11:
					;

				} finally { DebugExitSubRule(11); }


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("CURRENCY", 3);
			LeaveRule("CURRENCY", 3);
			LeaveRule_CURRENCY();
		}
	}
	// $ANTLR end "CURRENCY"

	partial void EnterRule_UNIT();
	partial void LeaveRule_UNIT();

	// $ANTLR start "UNIT"
	[GrammarRule("UNIT")]
	private void mUNIT()
	{
		EnterRule_UNIT();
		EnterRule("UNIT", 4);
		TraceIn("UNIT", 4);
		try
		{
			int _type = UNIT;
			int _channel = DefaultTokenChannel;
			// formula.g:51:2: ( FLOAT ( ' ' )? SI_UNIT | INTEGER SI_UNIT )
			int alt14=2;
			try { DebugEnterDecision(14, false);
			try
			{
				alt14 = dfa14.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:51:4: FLOAT ( ' ' )? SI_UNIT
				{
				DebugLocation(51, 4);
				mFLOAT(); 
				DebugLocation(51, 10);
				// formula.g:51:10: ( ' ' )?
				int alt13=2;
				try { DebugEnterSubRule(13);
				try { DebugEnterDecision(13, false);
				int LA13_0 = input.LA(1);

				if ((LA13_0==' '))
				{
					alt13 = 1;
				}
				} finally { DebugExitDecision(13); }
				switch (alt13)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:51:10: ' '
					{
					DebugLocation(51, 10);
					Match(' '); 

					}
					break;

				}
				} finally { DebugExitSubRule(13); }

				DebugLocation(51, 15);
				mSI_UNIT(); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:52:7: INTEGER SI_UNIT
				{
				DebugLocation(52, 7);
				mINTEGER(); 
				DebugLocation(52, 15);
				mSI_UNIT(); 

				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("UNIT", 4);
			LeaveRule("UNIT", 4);
			LeaveRule_UNIT();
		}
	}
	// $ANTLR end "UNIT"

	partial void EnterRule_EXP();
	partial void LeaveRule_EXP();

	// $ANTLR start "EXP"
	[GrammarRule("EXP")]
	private void mEXP()
	{
		EnterRule_EXP();
		EnterRule("EXP", 5);
		TraceIn("EXP", 5);
		try
		{
			int _type = EXP;
			int _channel = DefaultTokenChannel;
			// formula.g:55:5: ( ( 'E' | 'e' ) ( '+' | '-' )? ( DIGIT )+ )
			DebugEnterAlt(1);
			// formula.g:55:7: ( 'E' | 'e' ) ( '+' | '-' )? ( DIGIT )+
			{
			DebugLocation(55, 7);
			if (input.LA(1)=='E'||input.LA(1)=='e')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}

			DebugLocation(55, 17);
			// formula.g:55:17: ( '+' | '-' )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0=='+'||LA15_0=='-'))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:
				{
				DebugLocation(55, 17);
				input.Consume();


				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(55, 28);
			// formula.g:55:28: ( DIGIT )+
			int cnt16=0;
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if (((LA16_0>='1' && LA16_0<='9')))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch (alt16)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:55:28: DIGIT
					{
					DebugLocation(55, 28);
					mDIGIT(); 

					}
					break;

				default:
					if (cnt16 >= 1)
						goto loop16;

					EarlyExitException eee16 = new EarlyExitException( 16, input );
					DebugRecognitionException(eee16);
					throw eee16;
				}
				cnt16++;
			}
			loop16:
				;

			} finally { DebugExitSubRule(16); }


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("EXP", 5);
			LeaveRule("EXP", 5);
			LeaveRule_EXP();
		}
	}
	// $ANTLR end "EXP"

	partial void EnterRule_MULT();
	partial void LeaveRule_MULT();

	// $ANTLR start "MULT"
	[GrammarRule("MULT")]
	private void mMULT()
	{
		EnterRule_MULT();
		EnterRule("MULT", 6);
		TraceIn("MULT", 6);
		try
		{
			int _type = MULT;
			int _channel = DefaultTokenChannel;
			// formula.g:58:6: ( ( '*' | '.' | '·' ) )
			DebugEnterAlt(1);
			// formula.g:
			{
			DebugLocation(58, 6);
			if (input.LA(1)=='*'||input.LA(1)=='.'||input.LA(1)=='\u00B7')
			{
				input.Consume();
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				Recover(mse);
				throw mse;
			}


			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MULT", 6);
			LeaveRule("MULT", 6);
			LeaveRule_MULT();
		}
	}
	// $ANTLR end "MULT"

	partial void EnterRule_DIV();
	partial void LeaveRule_DIV();

	// $ANTLR start "DIV"
	[GrammarRule("DIV")]
	private void mDIV()
	{
		EnterRule_DIV();
		EnterRule("DIV", 7);
		TraceIn("DIV", 7);
		try
		{
			int _type = DIV;
			int _channel = DefaultTokenChannel;
			// formula.g:61:5: ( '/' )
			DebugEnterAlt(1);
			// formula.g:61:7: '/'
			{
			DebugLocation(61, 7);
			Match('/'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("DIV", 7);
			LeaveRule("DIV", 7);
			LeaveRule_DIV();
		}
	}
	// $ANTLR end "DIV"

	partial void EnterRule_PLUS();
	partial void LeaveRule_PLUS();

	// $ANTLR start "PLUS"
	[GrammarRule("PLUS")]
	private void mPLUS()
	{
		EnterRule_PLUS();
		EnterRule("PLUS", 8);
		TraceIn("PLUS", 8);
		try
		{
			int _type = PLUS;
			int _channel = DefaultTokenChannel;
			// formula.g:64:6: ( '+' )
			DebugEnterAlt(1);
			// formula.g:64:8: '+'
			{
			DebugLocation(64, 8);
			Match('+'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("PLUS", 8);
			LeaveRule("PLUS", 8);
			LeaveRule_PLUS();
		}
	}
	// $ANTLR end "PLUS"

	partial void EnterRule_MINUS();
	partial void LeaveRule_MINUS();

	// $ANTLR start "MINUS"
	[GrammarRule("MINUS")]
	private void mMINUS()
	{
		EnterRule_MINUS();
		EnterRule("MINUS", 9);
		TraceIn("MINUS", 9);
		try
		{
			int _type = MINUS;
			int _channel = DefaultTokenChannel;
			// formula.g:67:7: ( '-' )
			DebugEnterAlt(1);
			// formula.g:67:9: '-'
			{
			DebugLocation(67, 9);
			Match('-'); 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("MINUS", 9);
			LeaveRule("MINUS", 9);
			LeaveRule_MINUS();
		}
	}
	// $ANTLR end "MINUS"

	partial void EnterRule_POW();
	partial void LeaveRule_POW();

	// $ANTLR start "POW"
	[GrammarRule("POW")]
	private void mPOW()
	{
		EnterRule_POW();
		EnterRule("POW", 10);
		TraceIn("POW", 10);
		try
		{
			int _type = POW;
			int _channel = DefaultTokenChannel;
			// formula.g:70:5: ( '^' ( '+' | '-' )? ( DIGIT )+ | ( POW_DIGIT )+ )
			int alt20=2;
			try { DebugEnterDecision(20, false);
			int LA20_0 = input.LA(1);

			if ((LA20_0=='^'))
			{
				alt20 = 1;
			}
			else if (((LA20_0>='\u00B9' && LA20_0<='\u2079')))
			{
				alt20 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:70:7: '^' ( '+' | '-' )? ( DIGIT )+
				{
				DebugLocation(70, 7);
				Match('^'); 
				DebugLocation(70, 11);
				// formula.g:70:11: ( '+' | '-' )?
				int alt17=2;
				try { DebugEnterSubRule(17);
				try { DebugEnterDecision(17, false);
				int LA17_0 = input.LA(1);

				if ((LA17_0=='+'||LA17_0=='-'))
				{
					alt17 = 1;
				}
				} finally { DebugExitDecision(17); }
				switch (alt17)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(70, 11);
					input.Consume();


					}
					break;

				}
				} finally { DebugExitSubRule(17); }

				DebugLocation(70, 22);
				// formula.g:70:22: ( DIGIT )+
				int cnt18=0;
				try { DebugEnterSubRule(18);
				while (true)
				{
					int alt18=2;
					try { DebugEnterDecision(18, false);
					int LA18_0 = input.LA(1);

					if (((LA18_0>='1' && LA18_0<='9')))
					{
						alt18 = 1;
					}


					} finally { DebugExitDecision(18); }
					switch (alt18)
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:70:22: DIGIT
						{
						DebugLocation(70, 22);
						mDIGIT(); 

						}
						break;

					default:
						if (cnt18 >= 1)
							goto loop18;

						EarlyExitException eee18 = new EarlyExitException( 18, input );
						DebugRecognitionException(eee18);
						throw eee18;
					}
					cnt18++;
				}
				loop18:
					;

				} finally { DebugExitSubRule(18); }


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:71:7: ( POW_DIGIT )+
				{
				DebugLocation(71, 7);
				// formula.g:71:7: ( POW_DIGIT )+
				int cnt19=0;
				try { DebugEnterSubRule(19);
				while (true)
				{
					int alt19=2;
					try { DebugEnterDecision(19, false);
					int LA19_0 = input.LA(1);

					if (((LA19_0>='\u00B9' && LA19_0<='\u2079')))
					{
						alt19 = 1;
					}


					} finally { DebugExitDecision(19); }
					switch (alt19)
					{
					case 1:
						DebugEnterAlt(1);
						// formula.g:71:7: POW_DIGIT
						{
						DebugLocation(71, 7);
						mPOW_DIGIT(); 

						}
						break;

					default:
						if (cnt19 >= 1)
							goto loop19;

						EarlyExitException eee19 = new EarlyExitException( 19, input );
						DebugRecognitionException(eee19);
						throw eee19;
					}
					cnt19++;
				}
				loop19:
					;

				} finally { DebugExitSubRule(19); }


				}
				break;

			}
			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("POW", 10);
			LeaveRule("POW", 10);
			LeaveRule_POW();
		}
	}
	// $ANTLR end "POW"

	partial void EnterRule_POW_DIGIT();
	partial void LeaveRule_POW_DIGIT();

	// $ANTLR start "POW_DIGIT"
	[GrammarRule("POW_DIGIT")]
	private void mPOW_DIGIT()
	{
		EnterRule_POW_DIGIT();
		EnterRule("POW_DIGIT", 11);
		TraceIn("POW_DIGIT", 11);
		try
		{
			// formula.g:74:19: ( '¹' .. '⁹' ( '⁰' .. '⁹' )* )
			DebugEnterAlt(1);
			// formula.g:74:21: '¹' .. '⁹' ( '⁰' .. '⁹' )*
			{
			DebugLocation(74, 21);
			MatchRange('\u00B9','\u2079'); 
			DebugLocation(74, 30);
			// formula.g:74:30: ( '⁰' .. '⁹' )*
			try { DebugEnterSubRule(21);
			while (true)
			{
				int alt21=2;
				try { DebugEnterDecision(21, false);
				int LA21_0 = input.LA(1);

				if (((LA21_0>='\u2070' && LA21_0<='\u2079')))
				{
					alt21 = 1;
				}


				} finally { DebugExitDecision(21); }
				switch ( alt21 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(74, 30);
					input.Consume();


					}
					break;

				default:
					goto loop21;
				}
			}

			loop21:
				;

			} finally { DebugExitSubRule(21); }


			}

		}
		finally
		{
			TraceOut("POW_DIGIT", 11);
			LeaveRule("POW_DIGIT", 11);
			LeaveRule_POW_DIGIT();
		}
	}
	// $ANTLR end "POW_DIGIT"

	partial void EnterRule_WHITESPACE();
	partial void LeaveRule_WHITESPACE();

	// $ANTLR start "WHITESPACE"
	[GrammarRule("WHITESPACE")]
	private void mWHITESPACE()
	{
		EnterRule_WHITESPACE();
		EnterRule("WHITESPACE", 12);
		TraceIn("WHITESPACE", 12);
		try
		{
			int _type = WHITESPACE;
			int _channel = DefaultTokenChannel;
			// formula.g:76:12: ( ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+ )
			DebugEnterAlt(1);
			// formula.g:76:14: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
			{
			DebugLocation(76, 14);
			// formula.g:76:14: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
			int cnt22=0;
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if (((LA22_0>='\t' && LA22_0<='\n')||(LA22_0>='\f' && LA22_0<='\r')||LA22_0==' '))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(76, 14);
					input.Consume();


					}
					break;

				default:
					if (cnt22 >= 1)
						goto loop22;

					EarlyExitException eee22 = new EarlyExitException( 22, input );
					DebugRecognitionException(eee22);
					throw eee22;
				}
				cnt22++;
			}
			loop22:
				;

			} finally { DebugExitSubRule(22); }

			DebugLocation(76, 57);
			 _channel = Hidden; 

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally
		{
			TraceOut("WHITESPACE", 12);
			LeaveRule("WHITESPACE", 12);
			LeaveRule_WHITESPACE();
		}
	}
	// $ANTLR end "WHITESPACE"

	partial void EnterRule_SI_UNIT();
	partial void LeaveRule_SI_UNIT();

	// $ANTLR start "SI_UNIT"
	[GrammarRule("SI_UNIT")]
	private void mSI_UNIT()
	{
		EnterRule_SI_UNIT();
		EnterRule("SI_UNIT", 13);
		TraceIn("SI_UNIT", 13);
		try
		{
			// formula.g:78:18: ( ( SI_METER | SI_KG | SI_SEC | SI_AMP | SI_KELVIN | SI_MOLE | SI_CANDELA | SI_SQ_METER_1 | SI_SQ_METER_2 | SI_CU_METER_1 | SI_CU_METER_2 | SI_MPS | SI_MPS_SQ_1 | SI_MPS_SQ_2 | SI_REC_METER_1 | SI_REC_METER_2 | SI_KG_CU_METER_1 | SI_KG_CU_METER_2 | SI_CU_METER_KG_1 | SI_CU_METER_KG_2 | SI_AMP_SQ_METER_1 | SI_AMP_SQ_METER_2 | SI_AMP_METER | SI_MOL_CU_METER_1 | SI_MOL_CU_METER_2 | SI_CANDELA_SQ_METER_1 | SI_CANDELA_SQ_METER_2 | SI_RADIAN | SI_SOLID_ANGLE | SI_HERTZ | SI_NEWTON | SI_PASCAL | SI_JOULE | SI_WATT | SI_COULOMB | SI_VOLT | SI_FARAD | SI_OHM_1 | SI_OHM_2 | SI_SIEMENS | SI_WEBER | SI_TESLA | SI_HENRY | SI_CELCIUS | SI_LUMEN | SI_LUX | SI_BECQUEREL | SI_GRAY | SI_SIEVERT | SI_KATAL | SI_PASCAL_SEC | SI_NEWTON_METER | SI_NEWTON_PER_METER | SI_RADIAN_PER_SEC | SI_RADIAN_PER_SEC_SQ_1 | SI_RADIAN_PER_SEC_SQ_2 | SI_WATT_PER_METER_SQ_1 | SI_WATT_PER_METER_SQ_2 | SI_JOULE_PER_KELVIN | SI_JOULE_PER_KG_KELVIN | SI_JOULE_PER_KG | SI_WATT_PER_METER_KELVIN | SI_JOULE_PER_CU_METER_1 | SI_JOULE_PER_CU_METER_2 | SI_VOLT_PER_METER | SI_COULOMB_PER_CU_METER_1 | SI_COULOMB_PER_CU_METER_2 | SI_COULOMB_PER_SQ_METER_1 | SI_COULOMB_PER_SQ_METER_2 | SI_FARAD_PER_METER | SI_HENRY_PER_METER | SI_JOULE_PER_MOLE | SI_JOULE_PER_MOLE_KELVIN | SI_COULOMB_PER_KG | SI_GRAY_PER_SEC | SI_WATT_PER_STERADIAN | SI_WATT_PER_SQ_METER_STERADIAN_1 | SI_WATT_PER_SQ_METER_STERADIAN_2 | SI_KATAL_PER_CU_METER_1 | SI_KATAL_PER_CU_METER_2 ) )
			DebugEnterAlt(1);
			// formula.g:78:20: ( SI_METER | SI_KG | SI_SEC | SI_AMP | SI_KELVIN | SI_MOLE | SI_CANDELA | SI_SQ_METER_1 | SI_SQ_METER_2 | SI_CU_METER_1 | SI_CU_METER_2 | SI_MPS | SI_MPS_SQ_1 | SI_MPS_SQ_2 | SI_REC_METER_1 | SI_REC_METER_2 | SI_KG_CU_METER_1 | SI_KG_CU_METER_2 | SI_CU_METER_KG_1 | SI_CU_METER_KG_2 | SI_AMP_SQ_METER_1 | SI_AMP_SQ_METER_2 | SI_AMP_METER | SI_MOL_CU_METER_1 | SI_MOL_CU_METER_2 | SI_CANDELA_SQ_METER_1 | SI_CANDELA_SQ_METER_2 | SI_RADIAN | SI_SOLID_ANGLE | SI_HERTZ | SI_NEWTON | SI_PASCAL | SI_JOULE | SI_WATT | SI_COULOMB | SI_VOLT | SI_FARAD | SI_OHM_1 | SI_OHM_2 | SI_SIEMENS | SI_WEBER | SI_TESLA | SI_HENRY | SI_CELCIUS | SI_LUMEN | SI_LUX | SI_BECQUEREL | SI_GRAY | SI_SIEVERT | SI_KATAL | SI_PASCAL_SEC | SI_NEWTON_METER | SI_NEWTON_PER_METER | SI_RADIAN_PER_SEC | SI_RADIAN_PER_SEC_SQ_1 | SI_RADIAN_PER_SEC_SQ_2 | SI_WATT_PER_METER_SQ_1 | SI_WATT_PER_METER_SQ_2 | SI_JOULE_PER_KELVIN | SI_JOULE_PER_KG_KELVIN | SI_JOULE_PER_KG | SI_WATT_PER_METER_KELVIN | SI_JOULE_PER_CU_METER_1 | SI_JOULE_PER_CU_METER_2 | SI_VOLT_PER_METER | SI_COULOMB_PER_CU_METER_1 | SI_COULOMB_PER_CU_METER_2 | SI_COULOMB_PER_SQ_METER_1 | SI_COULOMB_PER_SQ_METER_2 | SI_FARAD_PER_METER | SI_HENRY_PER_METER | SI_JOULE_PER_MOLE | SI_JOULE_PER_MOLE_KELVIN | SI_COULOMB_PER_KG | SI_GRAY_PER_SEC | SI_WATT_PER_STERADIAN | SI_WATT_PER_SQ_METER_STERADIAN_1 | SI_WATT_PER_SQ_METER_STERADIAN_2 | SI_KATAL_PER_CU_METER_1 | SI_KATAL_PER_CU_METER_2 )
			{
			DebugLocation(78, 20);
			// formula.g:78:20: ( SI_METER | SI_KG | SI_SEC | SI_AMP | SI_KELVIN | SI_MOLE | SI_CANDELA | SI_SQ_METER_1 | SI_SQ_METER_2 | SI_CU_METER_1 | SI_CU_METER_2 | SI_MPS | SI_MPS_SQ_1 | SI_MPS_SQ_2 | SI_REC_METER_1 | SI_REC_METER_2 | SI_KG_CU_METER_1 | SI_KG_CU_METER_2 | SI_CU_METER_KG_1 | SI_CU_METER_KG_2 | SI_AMP_SQ_METER_1 | SI_AMP_SQ_METER_2 | SI_AMP_METER | SI_MOL_CU_METER_1 | SI_MOL_CU_METER_2 | SI_CANDELA_SQ_METER_1 | SI_CANDELA_SQ_METER_2 | SI_RADIAN | SI_SOLID_ANGLE | SI_HERTZ | SI_NEWTON | SI_PASCAL | SI_JOULE | SI_WATT | SI_COULOMB | SI_VOLT | SI_FARAD | SI_OHM_1 | SI_OHM_2 | SI_SIEMENS | SI_WEBER | SI_TESLA | SI_HENRY | SI_CELCIUS | SI_LUMEN | SI_LUX | SI_BECQUEREL | SI_GRAY | SI_SIEVERT | SI_KATAL | SI_PASCAL_SEC | SI_NEWTON_METER | SI_NEWTON_PER_METER | SI_RADIAN_PER_SEC | SI_RADIAN_PER_SEC_SQ_1 | SI_RADIAN_PER_SEC_SQ_2 | SI_WATT_PER_METER_SQ_1 | SI_WATT_PER_METER_SQ_2 | SI_JOULE_PER_KELVIN | SI_JOULE_PER_KG_KELVIN | SI_JOULE_PER_KG | SI_WATT_PER_METER_KELVIN | SI_JOULE_PER_CU_METER_1 | SI_JOULE_PER_CU_METER_2 | SI_VOLT_PER_METER | SI_COULOMB_PER_CU_METER_1 | SI_COULOMB_PER_CU_METER_2 | SI_COULOMB_PER_SQ_METER_1 | SI_COULOMB_PER_SQ_METER_2 | SI_FARAD_PER_METER | SI_HENRY_PER_METER | SI_JOULE_PER_MOLE | SI_JOULE_PER_MOLE_KELVIN | SI_COULOMB_PER_KG | SI_GRAY_PER_SEC | SI_WATT_PER_STERADIAN | SI_WATT_PER_SQ_METER_STERADIAN_1 | SI_WATT_PER_SQ_METER_STERADIAN_2 | SI_KATAL_PER_CU_METER_1 | SI_KATAL_PER_CU_METER_2 )
			int alt23=80;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			try
			{
				alt23 = dfa23.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:78:21: SI_METER
				{
				DebugLocation(78, 21);
				mSI_METER(); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:78:30: SI_KG
				{
				DebugLocation(78, 30);
				mSI_KG(); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// formula.g:78:36: SI_SEC
				{
				DebugLocation(78, 36);
				mSI_SEC(); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// formula.g:78:43: SI_AMP
				{
				DebugLocation(78, 43);
				mSI_AMP(); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// formula.g:78:50: SI_KELVIN
				{
				DebugLocation(78, 50);
				mSI_KELVIN(); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// formula.g:78:60: SI_MOLE
				{
				DebugLocation(78, 60);
				mSI_MOLE(); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// formula.g:78:68: SI_CANDELA
				{
				DebugLocation(78, 68);
				mSI_CANDELA(); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// formula.g:79:10: SI_SQ_METER_1
				{
				DebugLocation(79, 10);
				mSI_SQ_METER_1(); 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// formula.g:79:24: SI_SQ_METER_2
				{
				DebugLocation(79, 24);
				mSI_SQ_METER_2(); 

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// formula.g:79:38: SI_CU_METER_1
				{
				DebugLocation(79, 38);
				mSI_CU_METER_1(); 

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// formula.g:79:52: SI_CU_METER_2
				{
				DebugLocation(79, 52);
				mSI_CU_METER_2(); 

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// formula.g:79:66: SI_MPS
				{
				DebugLocation(79, 66);
				mSI_MPS(); 

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// formula.g:80:10: SI_MPS_SQ_1
				{
				DebugLocation(80, 10);
				mSI_MPS_SQ_1(); 

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// formula.g:80:22: SI_MPS_SQ_2
				{
				DebugLocation(80, 22);
				mSI_MPS_SQ_2(); 

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// formula.g:80:34: SI_REC_METER_1
				{
				DebugLocation(80, 34);
				mSI_REC_METER_1(); 

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// formula.g:80:49: SI_REC_METER_2
				{
				DebugLocation(80, 49);
				mSI_REC_METER_2(); 

				}
				break;
			case 17:
				DebugEnterAlt(17);
				// formula.g:80:64: SI_KG_CU_METER_1
				{
				DebugLocation(80, 64);
				mSI_KG_CU_METER_1(); 

				}
				break;
			case 18:
				DebugEnterAlt(18);
				// formula.g:81:10: SI_KG_CU_METER_2
				{
				DebugLocation(81, 10);
				mSI_KG_CU_METER_2(); 

				}
				break;
			case 19:
				DebugEnterAlt(19);
				// formula.g:81:27: SI_CU_METER_KG_1
				{
				DebugLocation(81, 27);
				mSI_CU_METER_KG_1(); 

				}
				break;
			case 20:
				DebugEnterAlt(20);
				// formula.g:81:44: SI_CU_METER_KG_2
				{
				DebugLocation(81, 44);
				mSI_CU_METER_KG_2(); 

				}
				break;
			case 21:
				DebugEnterAlt(21);
				// formula.g:81:61: SI_AMP_SQ_METER_1
				{
				DebugLocation(81, 61);
				mSI_AMP_SQ_METER_1(); 

				}
				break;
			case 22:
				DebugEnterAlt(22);
				// formula.g:82:10: SI_AMP_SQ_METER_2
				{
				DebugLocation(82, 10);
				mSI_AMP_SQ_METER_2(); 

				}
				break;
			case 23:
				DebugEnterAlt(23);
				// formula.g:82:28: SI_AMP_METER
				{
				DebugLocation(82, 28);
				mSI_AMP_METER(); 

				}
				break;
			case 24:
				DebugEnterAlt(24);
				// formula.g:82:41: SI_MOL_CU_METER_1
				{
				DebugLocation(82, 41);
				mSI_MOL_CU_METER_1(); 

				}
				break;
			case 25:
				DebugEnterAlt(25);
				// formula.g:82:59: SI_MOL_CU_METER_2
				{
				DebugLocation(82, 59);
				mSI_MOL_CU_METER_2(); 

				}
				break;
			case 26:
				DebugEnterAlt(26);
				// formula.g:83:10: SI_CANDELA_SQ_METER_1
				{
				DebugLocation(83, 10);
				mSI_CANDELA_SQ_METER_1(); 

				}
				break;
			case 27:
				DebugEnterAlt(27);
				// formula.g:83:32: SI_CANDELA_SQ_METER_2
				{
				DebugLocation(83, 32);
				mSI_CANDELA_SQ_METER_2(); 

				}
				break;
			case 28:
				DebugEnterAlt(28);
				// formula.g:83:54: SI_RADIAN
				{
				DebugLocation(83, 54);
				mSI_RADIAN(); 

				}
				break;
			case 29:
				DebugEnterAlt(29);
				// formula.g:83:64: SI_SOLID_ANGLE
				{
				DebugLocation(83, 64);
				mSI_SOLID_ANGLE(); 

				}
				break;
			case 30:
				DebugEnterAlt(30);
				// formula.g:84:10: SI_HERTZ
				{
				DebugLocation(84, 10);
				mSI_HERTZ(); 

				}
				break;
			case 31:
				DebugEnterAlt(31);
				// formula.g:84:19: SI_NEWTON
				{
				DebugLocation(84, 19);
				mSI_NEWTON(); 

				}
				break;
			case 32:
				DebugEnterAlt(32);
				// formula.g:84:29: SI_PASCAL
				{
				DebugLocation(84, 29);
				mSI_PASCAL(); 

				}
				break;
			case 33:
				DebugEnterAlt(33);
				// formula.g:84:39: SI_JOULE
				{
				DebugLocation(84, 39);
				mSI_JOULE(); 

				}
				break;
			case 34:
				DebugEnterAlt(34);
				// formula.g:84:48: SI_WATT
				{
				DebugLocation(84, 48);
				mSI_WATT(); 

				}
				break;
			case 35:
				DebugEnterAlt(35);
				// formula.g:84:56: SI_COULOMB
				{
				DebugLocation(84, 56);
				mSI_COULOMB(); 

				}
				break;
			case 36:
				DebugEnterAlt(36);
				// formula.g:84:67: SI_VOLT
				{
				DebugLocation(84, 67);
				mSI_VOLT(); 

				}
				break;
			case 37:
				DebugEnterAlt(37);
				// formula.g:85:10: SI_FARAD
				{
				DebugLocation(85, 10);
				mSI_FARAD(); 

				}
				break;
			case 38:
				DebugEnterAlt(38);
				// formula.g:85:19: SI_OHM_1
				{
				DebugLocation(85, 19);
				mSI_OHM_1(); 

				}
				break;
			case 39:
				DebugEnterAlt(39);
				// formula.g:85:28: SI_OHM_2
				{
				DebugLocation(85, 28);
				mSI_OHM_2(); 

				}
				break;
			case 40:
				DebugEnterAlt(40);
				// formula.g:85:37: SI_SIEMENS
				{
				DebugLocation(85, 37);
				mSI_SIEMENS(); 

				}
				break;
			case 41:
				DebugEnterAlt(41);
				// formula.g:85:48: SI_WEBER
				{
				DebugLocation(85, 48);
				mSI_WEBER(); 

				}
				break;
			case 42:
				DebugEnterAlt(42);
				// formula.g:85:57: SI_TESLA
				{
				DebugLocation(85, 57);
				mSI_TESLA(); 

				}
				break;
			case 43:
				DebugEnterAlt(43);
				// formula.g:85:66: SI_HENRY
				{
				DebugLocation(85, 66);
				mSI_HENRY(); 

				}
				break;
			case 44:
				DebugEnterAlt(44);
				// formula.g:86:10: SI_CELCIUS
				{
				DebugLocation(86, 10);
				mSI_CELCIUS(); 

				}
				break;
			case 45:
				DebugEnterAlt(45);
				// formula.g:86:21: SI_LUMEN
				{
				DebugLocation(86, 21);
				mSI_LUMEN(); 

				}
				break;
			case 46:
				DebugEnterAlt(46);
				// formula.g:86:30: SI_LUX
				{
				DebugLocation(86, 30);
				mSI_LUX(); 

				}
				break;
			case 47:
				DebugEnterAlt(47);
				// formula.g:86:37: SI_BECQUEREL
				{
				DebugLocation(86, 37);
				mSI_BECQUEREL(); 

				}
				break;
			case 48:
				DebugEnterAlt(48);
				// formula.g:86:50: SI_GRAY
				{
				DebugLocation(86, 50);
				mSI_GRAY(); 

				}
				break;
			case 49:
				DebugEnterAlt(49);
				// formula.g:86:58: SI_SIEVERT
				{
				DebugLocation(86, 58);
				mSI_SIEVERT(); 

				}
				break;
			case 50:
				DebugEnterAlt(50);
				// formula.g:86:69: SI_KATAL
				{
				DebugLocation(86, 69);
				mSI_KATAL(); 

				}
				break;
			case 51:
				DebugEnterAlt(51);
				// formula.g:87:10: SI_PASCAL_SEC
				{
				DebugLocation(87, 10);
				mSI_PASCAL_SEC(); 

				}
				break;
			case 52:
				DebugEnterAlt(52);
				// formula.g:87:24: SI_NEWTON_METER
				{
				DebugLocation(87, 24);
				mSI_NEWTON_METER(); 

				}
				break;
			case 53:
				DebugEnterAlt(53);
				// formula.g:87:40: SI_NEWTON_PER_METER
				{
				DebugLocation(87, 40);
				mSI_NEWTON_PER_METER(); 

				}
				break;
			case 54:
				DebugEnterAlt(54);
				// formula.g:87:60: SI_RADIAN_PER_SEC
				{
				DebugLocation(87, 60);
				mSI_RADIAN_PER_SEC(); 

				}
				break;
			case 55:
				DebugEnterAlt(55);
				// formula.g:88:10: SI_RADIAN_PER_SEC_SQ_1
				{
				DebugLocation(88, 10);
				mSI_RADIAN_PER_SEC_SQ_1(); 

				}
				break;
			case 56:
				DebugEnterAlt(56);
				// formula.g:88:33: SI_RADIAN_PER_SEC_SQ_2
				{
				DebugLocation(88, 33);
				mSI_RADIAN_PER_SEC_SQ_2(); 

				}
				break;
			case 57:
				DebugEnterAlt(57);
				// formula.g:88:56: SI_WATT_PER_METER_SQ_1
				{
				DebugLocation(88, 56);
				mSI_WATT_PER_METER_SQ_1(); 

				}
				break;
			case 58:
				DebugEnterAlt(58);
				// formula.g:89:10: SI_WATT_PER_METER_SQ_2
				{
				DebugLocation(89, 10);
				mSI_WATT_PER_METER_SQ_2(); 

				}
				break;
			case 59:
				DebugEnterAlt(59);
				// formula.g:89:33: SI_JOULE_PER_KELVIN
				{
				DebugLocation(89, 33);
				mSI_JOULE_PER_KELVIN(); 

				}
				break;
			case 60:
				DebugEnterAlt(60);
				// formula.g:89:53: SI_JOULE_PER_KG_KELVIN
				{
				DebugLocation(89, 53);
				mSI_JOULE_PER_KG_KELVIN(); 

				}
				break;
			case 61:
				DebugEnterAlt(61);
				// formula.g:90:10: SI_JOULE_PER_KG
				{
				DebugLocation(90, 10);
				mSI_JOULE_PER_KG(); 

				}
				break;
			case 62:
				DebugEnterAlt(62);
				// formula.g:90:26: SI_WATT_PER_METER_KELVIN
				{
				DebugLocation(90, 26);
				mSI_WATT_PER_METER_KELVIN(); 

				}
				break;
			case 63:
				DebugEnterAlt(63);
				// formula.g:90:51: SI_JOULE_PER_CU_METER_1
				{
				DebugLocation(90, 51);
				mSI_JOULE_PER_CU_METER_1(); 

				}
				break;
			case 64:
				DebugEnterAlt(64);
				// formula.g:91:10: SI_JOULE_PER_CU_METER_2
				{
				DebugLocation(91, 10);
				mSI_JOULE_PER_CU_METER_2(); 

				}
				break;
			case 65:
				DebugEnterAlt(65);
				// formula.g:91:34: SI_VOLT_PER_METER
				{
				DebugLocation(91, 34);
				mSI_VOLT_PER_METER(); 

				}
				break;
			case 66:
				DebugEnterAlt(66);
				// formula.g:91:52: SI_COULOMB_PER_CU_METER_1
				{
				DebugLocation(91, 52);
				mSI_COULOMB_PER_CU_METER_1(); 

				}
				break;
			case 67:
				DebugEnterAlt(67);
				// formula.g:92:10: SI_COULOMB_PER_CU_METER_2
				{
				DebugLocation(92, 10);
				mSI_COULOMB_PER_CU_METER_2(); 

				}
				break;
			case 68:
				DebugEnterAlt(68);
				// formula.g:92:36: SI_COULOMB_PER_SQ_METER_1
				{
				DebugLocation(92, 36);
				mSI_COULOMB_PER_SQ_METER_1(); 

				}
				break;
			case 69:
				DebugEnterAlt(69);
				// formula.g:93:10: SI_COULOMB_PER_SQ_METER_2
				{
				DebugLocation(93, 10);
				mSI_COULOMB_PER_SQ_METER_2(); 

				}
				break;
			case 70:
				DebugEnterAlt(70);
				// formula.g:93:36: SI_FARAD_PER_METER
				{
				DebugLocation(93, 36);
				mSI_FARAD_PER_METER(); 

				}
				break;
			case 71:
				DebugEnterAlt(71);
				// formula.g:93:55: SI_HENRY_PER_METER
				{
				DebugLocation(93, 55);
				mSI_HENRY_PER_METER(); 

				}
				break;
			case 72:
				DebugEnterAlt(72);
				// formula.g:94:10: SI_JOULE_PER_MOLE
				{
				DebugLocation(94, 10);
				mSI_JOULE_PER_MOLE(); 

				}
				break;
			case 73:
				DebugEnterAlt(73);
				// formula.g:94:28: SI_JOULE_PER_MOLE_KELVIN
				{
				DebugLocation(94, 28);
				mSI_JOULE_PER_MOLE_KELVIN(); 

				}
				break;
			case 74:
				DebugEnterAlt(74);
				// formula.g:94:53: SI_COULOMB_PER_KG
				{
				DebugLocation(94, 53);
				mSI_COULOMB_PER_KG(); 

				}
				break;
			case 75:
				DebugEnterAlt(75);
				// formula.g:95:10: SI_GRAY_PER_SEC
				{
				DebugLocation(95, 10);
				mSI_GRAY_PER_SEC(); 

				}
				break;
			case 76:
				DebugEnterAlt(76);
				// formula.g:95:26: SI_WATT_PER_STERADIAN
				{
				DebugLocation(95, 26);
				mSI_WATT_PER_STERADIAN(); 

				}
				break;
			case 77:
				DebugEnterAlt(77);
				// formula.g:95:48: SI_WATT_PER_SQ_METER_STERADIAN_1
				{
				DebugLocation(95, 48);
				mSI_WATT_PER_SQ_METER_STERADIAN_1(); 

				}
				break;
			case 78:
				DebugEnterAlt(78);
				// formula.g:96:10: SI_WATT_PER_SQ_METER_STERADIAN_2
				{
				DebugLocation(96, 10);
				mSI_WATT_PER_SQ_METER_STERADIAN_2(); 

				}
				break;
			case 79:
				DebugEnterAlt(79);
				// formula.g:96:43: SI_KATAL_PER_CU_METER_1
				{
				DebugLocation(96, 43);
				mSI_KATAL_PER_CU_METER_1(); 

				}
				break;
			case 80:
				DebugEnterAlt(80);
				// formula.g:97:10: SI_KATAL_PER_CU_METER_2
				{
				DebugLocation(97, 10);
				mSI_KATAL_PER_CU_METER_2(); 

				}
				break;

			}
			} finally { DebugExitSubRule(23); }


			}

		}
		finally
		{
			TraceOut("SI_UNIT", 13);
			LeaveRule("SI_UNIT", 13);
			LeaveRule_SI_UNIT();
		}
	}
	// $ANTLR end "SI_UNIT"

	partial void EnterRule_SI_METER();
	partial void LeaveRule_SI_METER();

	// $ANTLR start "SI_METER"
	[GrammarRule("SI_METER")]
	private void mSI_METER()
	{
		EnterRule_SI_METER();
		EnterRule("SI_METER", 14);
		TraceIn("SI_METER", 14);
		try
		{
			// formula.g:102:18: ( 'm' )
			DebugEnterAlt(1);
			// formula.g:102:20: 'm'
			{
			DebugLocation(102, 20);
			Match('m'); 

			}

		}
		finally
		{
			TraceOut("SI_METER", 14);
			LeaveRule("SI_METER", 14);
			LeaveRule_SI_METER();
		}
	}
	// $ANTLR end "SI_METER"

	partial void EnterRule_SI_KG();
	partial void LeaveRule_SI_KG();

	// $ANTLR start "SI_KG"
	[GrammarRule("SI_KG")]
	private void mSI_KG()
	{
		EnterRule_SI_KG();
		EnterRule("SI_KG", 15);
		TraceIn("SI_KG", 15);
		try
		{
			// formula.g:103:15: ( 'kg' )
			DebugEnterAlt(1);
			// formula.g:103:17: 'kg'
			{
			DebugLocation(103, 17);
			Match("kg"); 


			}

		}
		finally
		{
			TraceOut("SI_KG", 15);
			LeaveRule("SI_KG", 15);
			LeaveRule_SI_KG();
		}
	}
	// $ANTLR end "SI_KG"

	partial void EnterRule_SI_SEC();
	partial void LeaveRule_SI_SEC();

	// $ANTLR start "SI_SEC"
	[GrammarRule("SI_SEC")]
	private void mSI_SEC()
	{
		EnterRule_SI_SEC();
		EnterRule("SI_SEC", 16);
		TraceIn("SI_SEC", 16);
		try
		{
			// formula.g:104:16: ( 's' )
			DebugEnterAlt(1);
			// formula.g:104:18: 's'
			{
			DebugLocation(104, 18);
			Match('s'); 

			}

		}
		finally
		{
			TraceOut("SI_SEC", 16);
			LeaveRule("SI_SEC", 16);
			LeaveRule_SI_SEC();
		}
	}
	// $ANTLR end "SI_SEC"

	partial void EnterRule_SI_AMP();
	partial void LeaveRule_SI_AMP();

	// $ANTLR start "SI_AMP"
	[GrammarRule("SI_AMP")]
	private void mSI_AMP()
	{
		EnterRule_SI_AMP();
		EnterRule("SI_AMP", 17);
		TraceIn("SI_AMP", 17);
		try
		{
			// formula.g:105:16: ( 'A' )
			DebugEnterAlt(1);
			// formula.g:105:18: 'A'
			{
			DebugLocation(105, 18);
			Match('A'); 

			}

		}
		finally
		{
			TraceOut("SI_AMP", 17);
			LeaveRule("SI_AMP", 17);
			LeaveRule_SI_AMP();
		}
	}
	// $ANTLR end "SI_AMP"

	partial void EnterRule_SI_KELVIN();
	partial void LeaveRule_SI_KELVIN();

	// $ANTLR start "SI_KELVIN"
	[GrammarRule("SI_KELVIN")]
	private void mSI_KELVIN()
	{
		EnterRule_SI_KELVIN();
		EnterRule("SI_KELVIN", 18);
		TraceIn("SI_KELVIN", 18);
		try
		{
			// formula.g:106:19: ( 'K' )
			DebugEnterAlt(1);
			// formula.g:106:21: 'K'
			{
			DebugLocation(106, 21);
			Match('K'); 

			}

		}
		finally
		{
			TraceOut("SI_KELVIN", 18);
			LeaveRule("SI_KELVIN", 18);
			LeaveRule_SI_KELVIN();
		}
	}
	// $ANTLR end "SI_KELVIN"

	partial void EnterRule_SI_MOLE();
	partial void LeaveRule_SI_MOLE();

	// $ANTLR start "SI_MOLE"
	[GrammarRule("SI_MOLE")]
	private void mSI_MOLE()
	{
		EnterRule_SI_MOLE();
		EnterRule("SI_MOLE", 19);
		TraceIn("SI_MOLE", 19);
		try
		{
			// formula.g:107:17: ( 'mol' )
			DebugEnterAlt(1);
			// formula.g:107:19: 'mol'
			{
			DebugLocation(107, 19);
			Match("mol"); 


			}

		}
		finally
		{
			TraceOut("SI_MOLE", 19);
			LeaveRule("SI_MOLE", 19);
			LeaveRule_SI_MOLE();
		}
	}
	// $ANTLR end "SI_MOLE"

	partial void EnterRule_SI_CANDELA();
	partial void LeaveRule_SI_CANDELA();

	// $ANTLR start "SI_CANDELA"
	[GrammarRule("SI_CANDELA")]
	private void mSI_CANDELA()
	{
		EnterRule_SI_CANDELA();
		EnterRule("SI_CANDELA", 20);
		TraceIn("SI_CANDELA", 20);
		try
		{
			// formula.g:108:20: ( 'cd' )
			DebugEnterAlt(1);
			// formula.g:108:22: 'cd'
			{
			DebugLocation(108, 22);
			Match("cd"); 


			}

		}
		finally
		{
			TraceOut("SI_CANDELA", 20);
			LeaveRule("SI_CANDELA", 20);
			LeaveRule_SI_CANDELA();
		}
	}
	// $ANTLR end "SI_CANDELA"

	partial void EnterRule_SI_SQ_METER_1();
	partial void LeaveRule_SI_SQ_METER_1();

	// $ANTLR start "SI_SQ_METER_1"
	[GrammarRule("SI_SQ_METER_1")]
	private void mSI_SQ_METER_1()
	{
		EnterRule_SI_SQ_METER_1();
		EnterRule("SI_SQ_METER_1", 21);
		TraceIn("SI_SQ_METER_1", 21);
		try
		{
			// formula.g:111:23: ( 'm²' )
			DebugEnterAlt(1);
			// formula.g:111:25: 'm²'
			{
			DebugLocation(111, 25);
			Match("m²"); 


			}

		}
		finally
		{
			TraceOut("SI_SQ_METER_1", 21);
			LeaveRule("SI_SQ_METER_1", 21);
			LeaveRule_SI_SQ_METER_1();
		}
	}
	// $ANTLR end "SI_SQ_METER_1"

	partial void EnterRule_SI_SQ_METER_2();
	partial void LeaveRule_SI_SQ_METER_2();

	// $ANTLR start "SI_SQ_METER_2"
	[GrammarRule("SI_SQ_METER_2")]
	private void mSI_SQ_METER_2()
	{
		EnterRule_SI_SQ_METER_2();
		EnterRule("SI_SQ_METER_2", 22);
		TraceIn("SI_SQ_METER_2", 22);
		try
		{
			// formula.g:112:23: ( 'm^2' )
			DebugEnterAlt(1);
			// formula.g:112:25: 'm^2'
			{
			DebugLocation(112, 25);
			Match("m^2"); 


			}

		}
		finally
		{
			TraceOut("SI_SQ_METER_2", 22);
			LeaveRule("SI_SQ_METER_2", 22);
			LeaveRule_SI_SQ_METER_2();
		}
	}
	// $ANTLR end "SI_SQ_METER_2"

	partial void EnterRule_SI_CU_METER_1();
	partial void LeaveRule_SI_CU_METER_1();

	// $ANTLR start "SI_CU_METER_1"
	[GrammarRule("SI_CU_METER_1")]
	private void mSI_CU_METER_1()
	{
		EnterRule_SI_CU_METER_1();
		EnterRule("SI_CU_METER_1", 23);
		TraceIn("SI_CU_METER_1", 23);
		try
		{
			// formula.g:113:23: ( 'm³' )
			DebugEnterAlt(1);
			// formula.g:113:25: 'm³'
			{
			DebugLocation(113, 25);
			Match("m³"); 


			}

		}
		finally
		{
			TraceOut("SI_CU_METER_1", 23);
			LeaveRule("SI_CU_METER_1", 23);
			LeaveRule_SI_CU_METER_1();
		}
	}
	// $ANTLR end "SI_CU_METER_1"

	partial void EnterRule_SI_CU_METER_2();
	partial void LeaveRule_SI_CU_METER_2();

	// $ANTLR start "SI_CU_METER_2"
	[GrammarRule("SI_CU_METER_2")]
	private void mSI_CU_METER_2()
	{
		EnterRule_SI_CU_METER_2();
		EnterRule("SI_CU_METER_2", 24);
		TraceIn("SI_CU_METER_2", 24);
		try
		{
			// formula.g:114:23: ( 'm^3' )
			DebugEnterAlt(1);
			// formula.g:114:25: 'm^3'
			{
			DebugLocation(114, 25);
			Match("m^3"); 


			}

		}
		finally
		{
			TraceOut("SI_CU_METER_2", 24);
			LeaveRule("SI_CU_METER_2", 24);
			LeaveRule_SI_CU_METER_2();
		}
	}
	// $ANTLR end "SI_CU_METER_2"

	partial void EnterRule_SI_MPS();
	partial void LeaveRule_SI_MPS();

	// $ANTLR start "SI_MPS"
	[GrammarRule("SI_MPS")]
	private void mSI_MPS()
	{
		EnterRule_SI_MPS();
		EnterRule("SI_MPS", 25);
		TraceIn("SI_MPS", 25);
		try
		{
			// formula.g:115:16: ( 'm/s' )
			DebugEnterAlt(1);
			// formula.g:115:18: 'm/s'
			{
			DebugLocation(115, 18);
			Match("m/s"); 


			}

		}
		finally
		{
			TraceOut("SI_MPS", 25);
			LeaveRule("SI_MPS", 25);
			LeaveRule_SI_MPS();
		}
	}
	// $ANTLR end "SI_MPS"

	partial void EnterRule_SI_MPS_SQ_1();
	partial void LeaveRule_SI_MPS_SQ_1();

	// $ANTLR start "SI_MPS_SQ_1"
	[GrammarRule("SI_MPS_SQ_1")]
	private void mSI_MPS_SQ_1()
	{
		EnterRule_SI_MPS_SQ_1();
		EnterRule("SI_MPS_SQ_1", 26);
		TraceIn("SI_MPS_SQ_1", 26);
		try
		{
			// formula.g:116:21: ( 'm/s²' )
			DebugEnterAlt(1);
			// formula.g:116:23: 'm/s²'
			{
			DebugLocation(116, 23);
			Match("m/s²"); 


			}

		}
		finally
		{
			TraceOut("SI_MPS_SQ_1", 26);
			LeaveRule("SI_MPS_SQ_1", 26);
			LeaveRule_SI_MPS_SQ_1();
		}
	}
	// $ANTLR end "SI_MPS_SQ_1"

	partial void EnterRule_SI_MPS_SQ_2();
	partial void LeaveRule_SI_MPS_SQ_2();

	// $ANTLR start "SI_MPS_SQ_2"
	[GrammarRule("SI_MPS_SQ_2")]
	private void mSI_MPS_SQ_2()
	{
		EnterRule_SI_MPS_SQ_2();
		EnterRule("SI_MPS_SQ_2", 27);
		TraceIn("SI_MPS_SQ_2", 27);
		try
		{
			// formula.g:117:21: ( 'm/s^2' )
			DebugEnterAlt(1);
			// formula.g:117:23: 'm/s^2'
			{
			DebugLocation(117, 23);
			Match("m/s^2"); 


			}

		}
		finally
		{
			TraceOut("SI_MPS_SQ_2", 27);
			LeaveRule("SI_MPS_SQ_2", 27);
			LeaveRule_SI_MPS_SQ_2();
		}
	}
	// $ANTLR end "SI_MPS_SQ_2"

	partial void EnterRule_SI_REC_METER_1();
	partial void LeaveRule_SI_REC_METER_1();

	// $ANTLR start "SI_REC_METER_1"
	[GrammarRule("SI_REC_METER_1")]
	private void mSI_REC_METER_1()
	{
		EnterRule_SI_REC_METER_1();
		EnterRule("SI_REC_METER_1", 28);
		TraceIn("SI_REC_METER_1", 28);
		try
		{
			// formula.g:118:24: ( 'm⁻¹' )
			DebugEnterAlt(1);
			// formula.g:118:26: 'm⁻¹'
			{
			DebugLocation(118, 26);
			Match("m⁻¹"); 


			}

		}
		finally
		{
			TraceOut("SI_REC_METER_1", 28);
			LeaveRule("SI_REC_METER_1", 28);
			LeaveRule_SI_REC_METER_1();
		}
	}
	// $ANTLR end "SI_REC_METER_1"

	partial void EnterRule_SI_REC_METER_2();
	partial void LeaveRule_SI_REC_METER_2();

	// $ANTLR start "SI_REC_METER_2"
	[GrammarRule("SI_REC_METER_2")]
	private void mSI_REC_METER_2()
	{
		EnterRule_SI_REC_METER_2();
		EnterRule("SI_REC_METER_2", 29);
		TraceIn("SI_REC_METER_2", 29);
		try
		{
			// formula.g:119:24: ( 'm^-1' )
			DebugEnterAlt(1);
			// formula.g:119:26: 'm^-1'
			{
			DebugLocation(119, 26);
			Match("m^-1"); 


			}

		}
		finally
		{
			TraceOut("SI_REC_METER_2", 29);
			LeaveRule("SI_REC_METER_2", 29);
			LeaveRule_SI_REC_METER_2();
		}
	}
	// $ANTLR end "SI_REC_METER_2"

	partial void EnterRule_SI_KG_CU_METER_1();
	partial void LeaveRule_SI_KG_CU_METER_1();

	// $ANTLR start "SI_KG_CU_METER_1"
	[GrammarRule("SI_KG_CU_METER_1")]
	private void mSI_KG_CU_METER_1()
	{
		EnterRule_SI_KG_CU_METER_1();
		EnterRule("SI_KG_CU_METER_1", 30);
		TraceIn("SI_KG_CU_METER_1", 30);
		try
		{
			// formula.g:120:26: ( 'kg/m³' )
			DebugEnterAlt(1);
			// formula.g:120:28: 'kg/m³'
			{
			DebugLocation(120, 28);
			Match("kg/m³"); 


			}

		}
		finally
		{
			TraceOut("SI_KG_CU_METER_1", 30);
			LeaveRule("SI_KG_CU_METER_1", 30);
			LeaveRule_SI_KG_CU_METER_1();
		}
	}
	// $ANTLR end "SI_KG_CU_METER_1"

	partial void EnterRule_SI_KG_CU_METER_2();
	partial void LeaveRule_SI_KG_CU_METER_2();

	// $ANTLR start "SI_KG_CU_METER_2"
	[GrammarRule("SI_KG_CU_METER_2")]
	private void mSI_KG_CU_METER_2()
	{
		EnterRule_SI_KG_CU_METER_2();
		EnterRule("SI_KG_CU_METER_2", 31);
		TraceIn("SI_KG_CU_METER_2", 31);
		try
		{
			// formula.g:121:26: ( 'kg/m^3' )
			DebugEnterAlt(1);
			// formula.g:121:28: 'kg/m^3'
			{
			DebugLocation(121, 28);
			Match("kg/m^3"); 


			}

		}
		finally
		{
			TraceOut("SI_KG_CU_METER_2", 31);
			LeaveRule("SI_KG_CU_METER_2", 31);
			LeaveRule_SI_KG_CU_METER_2();
		}
	}
	// $ANTLR end "SI_KG_CU_METER_2"

	partial void EnterRule_SI_CU_METER_KG_1();
	partial void LeaveRule_SI_CU_METER_KG_1();

	// $ANTLR start "SI_CU_METER_KG_1"
	[GrammarRule("SI_CU_METER_KG_1")]
	private void mSI_CU_METER_KG_1()
	{
		EnterRule_SI_CU_METER_KG_1();
		EnterRule("SI_CU_METER_KG_1", 32);
		TraceIn("SI_CU_METER_KG_1", 32);
		try
		{
			// formula.g:122:26: ( 'm³/kg' )
			DebugEnterAlt(1);
			// formula.g:122:28: 'm³/kg'
			{
			DebugLocation(122, 28);
			Match("m³/kg"); 


			}

		}
		finally
		{
			TraceOut("SI_CU_METER_KG_1", 32);
			LeaveRule("SI_CU_METER_KG_1", 32);
			LeaveRule_SI_CU_METER_KG_1();
		}
	}
	// $ANTLR end "SI_CU_METER_KG_1"

	partial void EnterRule_SI_CU_METER_KG_2();
	partial void LeaveRule_SI_CU_METER_KG_2();

	// $ANTLR start "SI_CU_METER_KG_2"
	[GrammarRule("SI_CU_METER_KG_2")]
	private void mSI_CU_METER_KG_2()
	{
		EnterRule_SI_CU_METER_KG_2();
		EnterRule("SI_CU_METER_KG_2", 33);
		TraceIn("SI_CU_METER_KG_2", 33);
		try
		{
			// formula.g:123:26: ( 'm^3/kg' )
			DebugEnterAlt(1);
			// formula.g:123:28: 'm^3/kg'
			{
			DebugLocation(123, 28);
			Match("m^3/kg"); 


			}

		}
		finally
		{
			TraceOut("SI_CU_METER_KG_2", 33);
			LeaveRule("SI_CU_METER_KG_2", 33);
			LeaveRule_SI_CU_METER_KG_2();
		}
	}
	// $ANTLR end "SI_CU_METER_KG_2"

	partial void EnterRule_SI_AMP_SQ_METER_1();
	partial void LeaveRule_SI_AMP_SQ_METER_1();

	// $ANTLR start "SI_AMP_SQ_METER_1"
	[GrammarRule("SI_AMP_SQ_METER_1")]
	private void mSI_AMP_SQ_METER_1()
	{
		EnterRule_SI_AMP_SQ_METER_1();
		EnterRule("SI_AMP_SQ_METER_1", 34);
		TraceIn("SI_AMP_SQ_METER_1", 34);
		try
		{
			// formula.g:124:27: ( 'A/m²' )
			DebugEnterAlt(1);
			// formula.g:124:29: 'A/m²'
			{
			DebugLocation(124, 29);
			Match("A/m²"); 


			}

		}
		finally
		{
			TraceOut("SI_AMP_SQ_METER_1", 34);
			LeaveRule("SI_AMP_SQ_METER_1", 34);
			LeaveRule_SI_AMP_SQ_METER_1();
		}
	}
	// $ANTLR end "SI_AMP_SQ_METER_1"

	partial void EnterRule_SI_AMP_SQ_METER_2();
	partial void LeaveRule_SI_AMP_SQ_METER_2();

	// $ANTLR start "SI_AMP_SQ_METER_2"
	[GrammarRule("SI_AMP_SQ_METER_2")]
	private void mSI_AMP_SQ_METER_2()
	{
		EnterRule_SI_AMP_SQ_METER_2();
		EnterRule("SI_AMP_SQ_METER_2", 35);
		TraceIn("SI_AMP_SQ_METER_2", 35);
		try
		{
			// formula.g:125:27: ( 'A/m^2' )
			DebugEnterAlt(1);
			// formula.g:125:29: 'A/m^2'
			{
			DebugLocation(125, 29);
			Match("A/m^2"); 


			}

		}
		finally
		{
			TraceOut("SI_AMP_SQ_METER_2", 35);
			LeaveRule("SI_AMP_SQ_METER_2", 35);
			LeaveRule_SI_AMP_SQ_METER_2();
		}
	}
	// $ANTLR end "SI_AMP_SQ_METER_2"

	partial void EnterRule_SI_AMP_METER();
	partial void LeaveRule_SI_AMP_METER();

	// $ANTLR start "SI_AMP_METER"
	[GrammarRule("SI_AMP_METER")]
	private void mSI_AMP_METER()
	{
		EnterRule_SI_AMP_METER();
		EnterRule("SI_AMP_METER", 36);
		TraceIn("SI_AMP_METER", 36);
		try
		{
			// formula.g:126:22: ( 'A/m' )
			DebugEnterAlt(1);
			// formula.g:126:24: 'A/m'
			{
			DebugLocation(126, 24);
			Match("A/m"); 


			}

		}
		finally
		{
			TraceOut("SI_AMP_METER", 36);
			LeaveRule("SI_AMP_METER", 36);
			LeaveRule_SI_AMP_METER();
		}
	}
	// $ANTLR end "SI_AMP_METER"

	partial void EnterRule_SI_MOL_CU_METER_1();
	partial void LeaveRule_SI_MOL_CU_METER_1();

	// $ANTLR start "SI_MOL_CU_METER_1"
	[GrammarRule("SI_MOL_CU_METER_1")]
	private void mSI_MOL_CU_METER_1()
	{
		EnterRule_SI_MOL_CU_METER_1();
		EnterRule("SI_MOL_CU_METER_1", 37);
		TraceIn("SI_MOL_CU_METER_1", 37);
		try
		{
			// formula.g:127:27: ( 'mol/m³' )
			DebugEnterAlt(1);
			// formula.g:127:29: 'mol/m³'
			{
			DebugLocation(127, 29);
			Match("mol/m³"); 


			}

		}
		finally
		{
			TraceOut("SI_MOL_CU_METER_1", 37);
			LeaveRule("SI_MOL_CU_METER_1", 37);
			LeaveRule_SI_MOL_CU_METER_1();
		}
	}
	// $ANTLR end "SI_MOL_CU_METER_1"

	partial void EnterRule_SI_MOL_CU_METER_2();
	partial void LeaveRule_SI_MOL_CU_METER_2();

	// $ANTLR start "SI_MOL_CU_METER_2"
	[GrammarRule("SI_MOL_CU_METER_2")]
	private void mSI_MOL_CU_METER_2()
	{
		EnterRule_SI_MOL_CU_METER_2();
		EnterRule("SI_MOL_CU_METER_2", 38);
		TraceIn("SI_MOL_CU_METER_2", 38);
		try
		{
			// formula.g:128:27: ( 'mol/m^3' )
			DebugEnterAlt(1);
			// formula.g:128:29: 'mol/m^3'
			{
			DebugLocation(128, 29);
			Match("mol/m^3"); 


			}

		}
		finally
		{
			TraceOut("SI_MOL_CU_METER_2", 38);
			LeaveRule("SI_MOL_CU_METER_2", 38);
			LeaveRule_SI_MOL_CU_METER_2();
		}
	}
	// $ANTLR end "SI_MOL_CU_METER_2"

	partial void EnterRule_SI_CANDELA_SQ_METER_1();
	partial void LeaveRule_SI_CANDELA_SQ_METER_1();

	// $ANTLR start "SI_CANDELA_SQ_METER_1"
	[GrammarRule("SI_CANDELA_SQ_METER_1")]
	private void mSI_CANDELA_SQ_METER_1()
	{
		EnterRule_SI_CANDELA_SQ_METER_1();
		EnterRule("SI_CANDELA_SQ_METER_1", 39);
		TraceIn("SI_CANDELA_SQ_METER_1", 39);
		try
		{
			// formula.g:129:31: ( 'cd/m²' )
			DebugEnterAlt(1);
			// formula.g:129:33: 'cd/m²'
			{
			DebugLocation(129, 33);
			Match("cd/m²"); 


			}

		}
		finally
		{
			TraceOut("SI_CANDELA_SQ_METER_1", 39);
			LeaveRule("SI_CANDELA_SQ_METER_1", 39);
			LeaveRule_SI_CANDELA_SQ_METER_1();
		}
	}
	// $ANTLR end "SI_CANDELA_SQ_METER_1"

	partial void EnterRule_SI_CANDELA_SQ_METER_2();
	partial void LeaveRule_SI_CANDELA_SQ_METER_2();

	// $ANTLR start "SI_CANDELA_SQ_METER_2"
	[GrammarRule("SI_CANDELA_SQ_METER_2")]
	private void mSI_CANDELA_SQ_METER_2()
	{
		EnterRule_SI_CANDELA_SQ_METER_2();
		EnterRule("SI_CANDELA_SQ_METER_2", 40);
		TraceIn("SI_CANDELA_SQ_METER_2", 40);
		try
		{
			// formula.g:130:31: ( 'cd/m^2' )
			DebugEnterAlt(1);
			// formula.g:130:33: 'cd/m^2'
			{
			DebugLocation(130, 33);
			Match("cd/m^2"); 


			}

		}
		finally
		{
			TraceOut("SI_CANDELA_SQ_METER_2", 40);
			LeaveRule("SI_CANDELA_SQ_METER_2", 40);
			LeaveRule_SI_CANDELA_SQ_METER_2();
		}
	}
	// $ANTLR end "SI_CANDELA_SQ_METER_2"

	partial void EnterRule_SI_RADIAN();
	partial void LeaveRule_SI_RADIAN();

	// $ANTLR start "SI_RADIAN"
	[GrammarRule("SI_RADIAN")]
	private void mSI_RADIAN()
	{
		EnterRule_SI_RADIAN();
		EnterRule("SI_RADIAN", 41);
		TraceIn("SI_RADIAN", 41);
		try
		{
			// formula.g:132:19: ( 'rad' )
			DebugEnterAlt(1);
			// formula.g:132:21: 'rad'
			{
			DebugLocation(132, 21);
			Match("rad"); 


			}

		}
		finally
		{
			TraceOut("SI_RADIAN", 41);
			LeaveRule("SI_RADIAN", 41);
			LeaveRule_SI_RADIAN();
		}
	}
	// $ANTLR end "SI_RADIAN"

	partial void EnterRule_SI_SOLID_ANGLE();
	partial void LeaveRule_SI_SOLID_ANGLE();

	// $ANTLR start "SI_SOLID_ANGLE"
	[GrammarRule("SI_SOLID_ANGLE")]
	private void mSI_SOLID_ANGLE()
	{
		EnterRule_SI_SOLID_ANGLE();
		EnterRule("SI_SOLID_ANGLE", 42);
		TraceIn("SI_SOLID_ANGLE", 42);
		try
		{
			// formula.g:133:24: ( 'sr(c)' )
			DebugEnterAlt(1);
			// formula.g:133:26: 'sr(c)'
			{
			DebugLocation(133, 26);
			Match("sr(c)"); 


			}

		}
		finally
		{
			TraceOut("SI_SOLID_ANGLE", 42);
			LeaveRule("SI_SOLID_ANGLE", 42);
			LeaveRule_SI_SOLID_ANGLE();
		}
	}
	// $ANTLR end "SI_SOLID_ANGLE"

	partial void EnterRule_SI_HERTZ();
	partial void LeaveRule_SI_HERTZ();

	// $ANTLR start "SI_HERTZ"
	[GrammarRule("SI_HERTZ")]
	private void mSI_HERTZ()
	{
		EnterRule_SI_HERTZ();
		EnterRule("SI_HERTZ", 43);
		TraceIn("SI_HERTZ", 43);
		try
		{
			// formula.g:134:18: ( 'Hz' )
			DebugEnterAlt(1);
			// formula.g:134:20: 'Hz'
			{
			DebugLocation(134, 20);
			Match("Hz"); 


			}

		}
		finally
		{
			TraceOut("SI_HERTZ", 43);
			LeaveRule("SI_HERTZ", 43);
			LeaveRule_SI_HERTZ();
		}
	}
	// $ANTLR end "SI_HERTZ"

	partial void EnterRule_SI_NEWTON();
	partial void LeaveRule_SI_NEWTON();

	// $ANTLR start "SI_NEWTON"
	[GrammarRule("SI_NEWTON")]
	private void mSI_NEWTON()
	{
		EnterRule_SI_NEWTON();
		EnterRule("SI_NEWTON", 44);
		TraceIn("SI_NEWTON", 44);
		try
		{
			// formula.g:135:19: ( 'N' )
			DebugEnterAlt(1);
			// formula.g:135:21: 'N'
			{
			DebugLocation(135, 21);
			Match('N'); 

			}

		}
		finally
		{
			TraceOut("SI_NEWTON", 44);
			LeaveRule("SI_NEWTON", 44);
			LeaveRule_SI_NEWTON();
		}
	}
	// $ANTLR end "SI_NEWTON"

	partial void EnterRule_SI_PASCAL();
	partial void LeaveRule_SI_PASCAL();

	// $ANTLR start "SI_PASCAL"
	[GrammarRule("SI_PASCAL")]
	private void mSI_PASCAL()
	{
		EnterRule_SI_PASCAL();
		EnterRule("SI_PASCAL", 45);
		TraceIn("SI_PASCAL", 45);
		try
		{
			// formula.g:136:19: ( 'Pa' )
			DebugEnterAlt(1);
			// formula.g:136:21: 'Pa'
			{
			DebugLocation(136, 21);
			Match("Pa"); 


			}

		}
		finally
		{
			TraceOut("SI_PASCAL", 45);
			LeaveRule("SI_PASCAL", 45);
			LeaveRule_SI_PASCAL();
		}
	}
	// $ANTLR end "SI_PASCAL"

	partial void EnterRule_SI_JOULE();
	partial void LeaveRule_SI_JOULE();

	// $ANTLR start "SI_JOULE"
	[GrammarRule("SI_JOULE")]
	private void mSI_JOULE()
	{
		EnterRule_SI_JOULE();
		EnterRule("SI_JOULE", 46);
		TraceIn("SI_JOULE", 46);
		try
		{
			// formula.g:137:18: ( 'J' )
			DebugEnterAlt(1);
			// formula.g:137:20: 'J'
			{
			DebugLocation(137, 20);
			Match('J'); 

			}

		}
		finally
		{
			TraceOut("SI_JOULE", 46);
			LeaveRule("SI_JOULE", 46);
			LeaveRule_SI_JOULE();
		}
	}
	// $ANTLR end "SI_JOULE"

	partial void EnterRule_SI_WATT();
	partial void LeaveRule_SI_WATT();

	// $ANTLR start "SI_WATT"
	[GrammarRule("SI_WATT")]
	private void mSI_WATT()
	{
		EnterRule_SI_WATT();
		EnterRule("SI_WATT", 47);
		TraceIn("SI_WATT", 47);
		try
		{
			// formula.g:138:17: ( 'W' )
			DebugEnterAlt(1);
			// formula.g:138:19: 'W'
			{
			DebugLocation(138, 19);
			Match('W'); 

			}

		}
		finally
		{
			TraceOut("SI_WATT", 47);
			LeaveRule("SI_WATT", 47);
			LeaveRule_SI_WATT();
		}
	}
	// $ANTLR end "SI_WATT"

	partial void EnterRule_SI_COULOMB();
	partial void LeaveRule_SI_COULOMB();

	// $ANTLR start "SI_COULOMB"
	[GrammarRule("SI_COULOMB")]
	private void mSI_COULOMB()
	{
		EnterRule_SI_COULOMB();
		EnterRule("SI_COULOMB", 48);
		TraceIn("SI_COULOMB", 48);
		try
		{
			// formula.g:139:20: ( 'C' )
			DebugEnterAlt(1);
			// formula.g:139:22: 'C'
			{
			DebugLocation(139, 22);
			Match('C'); 

			}

		}
		finally
		{
			TraceOut("SI_COULOMB", 48);
			LeaveRule("SI_COULOMB", 48);
			LeaveRule_SI_COULOMB();
		}
	}
	// $ANTLR end "SI_COULOMB"

	partial void EnterRule_SI_VOLT();
	partial void LeaveRule_SI_VOLT();

	// $ANTLR start "SI_VOLT"
	[GrammarRule("SI_VOLT")]
	private void mSI_VOLT()
	{
		EnterRule_SI_VOLT();
		EnterRule("SI_VOLT", 49);
		TraceIn("SI_VOLT", 49);
		try
		{
			// formula.g:140:17: ( 'V' )
			DebugEnterAlt(1);
			// formula.g:140:19: 'V'
			{
			DebugLocation(140, 19);
			Match('V'); 

			}

		}
		finally
		{
			TraceOut("SI_VOLT", 49);
			LeaveRule("SI_VOLT", 49);
			LeaveRule_SI_VOLT();
		}
	}
	// $ANTLR end "SI_VOLT"

	partial void EnterRule_SI_FARAD();
	partial void LeaveRule_SI_FARAD();

	// $ANTLR start "SI_FARAD"
	[GrammarRule("SI_FARAD")]
	private void mSI_FARAD()
	{
		EnterRule_SI_FARAD();
		EnterRule("SI_FARAD", 50);
		TraceIn("SI_FARAD", 50);
		try
		{
			// formula.g:141:18: ( 'F' )
			DebugEnterAlt(1);
			// formula.g:141:20: 'F'
			{
			DebugLocation(141, 20);
			Match('F'); 

			}

		}
		finally
		{
			TraceOut("SI_FARAD", 50);
			LeaveRule("SI_FARAD", 50);
			LeaveRule_SI_FARAD();
		}
	}
	// $ANTLR end "SI_FARAD"

	partial void EnterRule_SI_OHM_1();
	partial void LeaveRule_SI_OHM_1();

	// $ANTLR start "SI_OHM_1"
	[GrammarRule("SI_OHM_1")]
	private void mSI_OHM_1()
	{
		EnterRule_SI_OHM_1();
		EnterRule("SI_OHM_1", 51);
		TraceIn("SI_OHM_1", 51);
		try
		{
			// formula.g:142:18: ( 'Ω' )
			DebugEnterAlt(1);
			// formula.g:142:20: 'Ω'
			{
			DebugLocation(142, 20);
			Match('\u2126'); 

			}

		}
		finally
		{
			TraceOut("SI_OHM_1", 51);
			LeaveRule("SI_OHM_1", 51);
			LeaveRule_SI_OHM_1();
		}
	}
	// $ANTLR end "SI_OHM_1"

	partial void EnterRule_SI_OHM_2();
	partial void LeaveRule_SI_OHM_2();

	// $ANTLR start "SI_OHM_2"
	[GrammarRule("SI_OHM_2")]
	private void mSI_OHM_2()
	{
		EnterRule_SI_OHM_2();
		EnterRule("SI_OHM_2", 52);
		TraceIn("SI_OHM_2", 52);
		try
		{
			// formula.g:143:18: ( 'ohm' )
			DebugEnterAlt(1);
			// formula.g:143:20: 'ohm'
			{
			DebugLocation(143, 20);
			Match("ohm"); 


			}

		}
		finally
		{
			TraceOut("SI_OHM_2", 52);
			LeaveRule("SI_OHM_2", 52);
			LeaveRule_SI_OHM_2();
		}
	}
	// $ANTLR end "SI_OHM_2"

	partial void EnterRule_SI_SIEMENS();
	partial void LeaveRule_SI_SIEMENS();

	// $ANTLR start "SI_SIEMENS"
	[GrammarRule("SI_SIEMENS")]
	private void mSI_SIEMENS()
	{
		EnterRule_SI_SIEMENS();
		EnterRule("SI_SIEMENS", 53);
		TraceIn("SI_SIEMENS", 53);
		try
		{
			// formula.g:144:20: ( 'S' )
			DebugEnterAlt(1);
			// formula.g:144:22: 'S'
			{
			DebugLocation(144, 22);
			Match('S'); 

			}

		}
		finally
		{
			TraceOut("SI_SIEMENS", 53);
			LeaveRule("SI_SIEMENS", 53);
			LeaveRule_SI_SIEMENS();
		}
	}
	// $ANTLR end "SI_SIEMENS"

	partial void EnterRule_SI_WEBER();
	partial void LeaveRule_SI_WEBER();

	// $ANTLR start "SI_WEBER"
	[GrammarRule("SI_WEBER")]
	private void mSI_WEBER()
	{
		EnterRule_SI_WEBER();
		EnterRule("SI_WEBER", 54);
		TraceIn("SI_WEBER", 54);
		try
		{
			// formula.g:145:18: ( 'Wb' )
			DebugEnterAlt(1);
			// formula.g:145:20: 'Wb'
			{
			DebugLocation(145, 20);
			Match("Wb"); 


			}

		}
		finally
		{
			TraceOut("SI_WEBER", 54);
			LeaveRule("SI_WEBER", 54);
			LeaveRule_SI_WEBER();
		}
	}
	// $ANTLR end "SI_WEBER"

	partial void EnterRule_SI_TESLA();
	partial void LeaveRule_SI_TESLA();

	// $ANTLR start "SI_TESLA"
	[GrammarRule("SI_TESLA")]
	private void mSI_TESLA()
	{
		EnterRule_SI_TESLA();
		EnterRule("SI_TESLA", 55);
		TraceIn("SI_TESLA", 55);
		try
		{
			// formula.g:146:18: ( 'T' )
			DebugEnterAlt(1);
			// formula.g:146:20: 'T'
			{
			DebugLocation(146, 20);
			Match('T'); 

			}

		}
		finally
		{
			TraceOut("SI_TESLA", 55);
			LeaveRule("SI_TESLA", 55);
			LeaveRule_SI_TESLA();
		}
	}
	// $ANTLR end "SI_TESLA"

	partial void EnterRule_SI_HENRY();
	partial void LeaveRule_SI_HENRY();

	// $ANTLR start "SI_HENRY"
	[GrammarRule("SI_HENRY")]
	private void mSI_HENRY()
	{
		EnterRule_SI_HENRY();
		EnterRule("SI_HENRY", 56);
		TraceIn("SI_HENRY", 56);
		try
		{
			// formula.g:147:18: ( 'H' )
			DebugEnterAlt(1);
			// formula.g:147:20: 'H'
			{
			DebugLocation(147, 20);
			Match('H'); 

			}

		}
		finally
		{
			TraceOut("SI_HENRY", 56);
			LeaveRule("SI_HENRY", 56);
			LeaveRule_SI_HENRY();
		}
	}
	// $ANTLR end "SI_HENRY"

	partial void EnterRule_SI_CELCIUS();
	partial void LeaveRule_SI_CELCIUS();

	// $ANTLR start "SI_CELCIUS"
	[GrammarRule("SI_CELCIUS")]
	private void mSI_CELCIUS()
	{
		EnterRule_SI_CELCIUS();
		EnterRule("SI_CELCIUS", 57);
		TraceIn("SI_CELCIUS", 57);
		try
		{
			// formula.g:148:20: ( '°C' )
			DebugEnterAlt(1);
			// formula.g:148:22: '°C'
			{
			DebugLocation(148, 22);
			Match("°C"); 


			}

		}
		finally
		{
			TraceOut("SI_CELCIUS", 57);
			LeaveRule("SI_CELCIUS", 57);
			LeaveRule_SI_CELCIUS();
		}
	}
	// $ANTLR end "SI_CELCIUS"

	partial void EnterRule_SI_LUMEN();
	partial void LeaveRule_SI_LUMEN();

	// $ANTLR start "SI_LUMEN"
	[GrammarRule("SI_LUMEN")]
	private void mSI_LUMEN()
	{
		EnterRule_SI_LUMEN();
		EnterRule("SI_LUMEN", 58);
		TraceIn("SI_LUMEN", 58);
		try
		{
			// formula.g:149:18: ( 'lm' )
			DebugEnterAlt(1);
			// formula.g:149:20: 'lm'
			{
			DebugLocation(149, 20);
			Match("lm"); 


			}

		}
		finally
		{
			TraceOut("SI_LUMEN", 58);
			LeaveRule("SI_LUMEN", 58);
			LeaveRule_SI_LUMEN();
		}
	}
	// $ANTLR end "SI_LUMEN"

	partial void EnterRule_SI_LUX();
	partial void LeaveRule_SI_LUX();

	// $ANTLR start "SI_LUX"
	[GrammarRule("SI_LUX")]
	private void mSI_LUX()
	{
		EnterRule_SI_LUX();
		EnterRule("SI_LUX", 59);
		TraceIn("SI_LUX", 59);
		try
		{
			// formula.g:150:16: ( 'lx' )
			DebugEnterAlt(1);
			// formula.g:150:18: 'lx'
			{
			DebugLocation(150, 18);
			Match("lx"); 


			}

		}
		finally
		{
			TraceOut("SI_LUX", 59);
			LeaveRule("SI_LUX", 59);
			LeaveRule_SI_LUX();
		}
	}
	// $ANTLR end "SI_LUX"

	partial void EnterRule_SI_BECQUEREL();
	partial void LeaveRule_SI_BECQUEREL();

	// $ANTLR start "SI_BECQUEREL"
	[GrammarRule("SI_BECQUEREL")]
	private void mSI_BECQUEREL()
	{
		EnterRule_SI_BECQUEREL();
		EnterRule("SI_BECQUEREL", 60);
		TraceIn("SI_BECQUEREL", 60);
		try
		{
			// formula.g:151:22: ( 'Bq' )
			DebugEnterAlt(1);
			// formula.g:151:24: 'Bq'
			{
			DebugLocation(151, 24);
			Match("Bq"); 


			}

		}
		finally
		{
			TraceOut("SI_BECQUEREL", 60);
			LeaveRule("SI_BECQUEREL", 60);
			LeaveRule_SI_BECQUEREL();
		}
	}
	// $ANTLR end "SI_BECQUEREL"

	partial void EnterRule_SI_GRAY();
	partial void LeaveRule_SI_GRAY();

	// $ANTLR start "SI_GRAY"
	[GrammarRule("SI_GRAY")]
	private void mSI_GRAY()
	{
		EnterRule_SI_GRAY();
		EnterRule("SI_GRAY", 61);
		TraceIn("SI_GRAY", 61);
		try
		{
			// formula.g:152:17: ( 'Gy' )
			DebugEnterAlt(1);
			// formula.g:152:19: 'Gy'
			{
			DebugLocation(152, 19);
			Match("Gy"); 


			}

		}
		finally
		{
			TraceOut("SI_GRAY", 61);
			LeaveRule("SI_GRAY", 61);
			LeaveRule_SI_GRAY();
		}
	}
	// $ANTLR end "SI_GRAY"

	partial void EnterRule_SI_SIEVERT();
	partial void LeaveRule_SI_SIEVERT();

	// $ANTLR start "SI_SIEVERT"
	[GrammarRule("SI_SIEVERT")]
	private void mSI_SIEVERT()
	{
		EnterRule_SI_SIEVERT();
		EnterRule("SI_SIEVERT", 62);
		TraceIn("SI_SIEVERT", 62);
		try
		{
			// formula.g:153:20: ( 'Sv' )
			DebugEnterAlt(1);
			// formula.g:153:22: 'Sv'
			{
			DebugLocation(153, 22);
			Match("Sv"); 


			}

		}
		finally
		{
			TraceOut("SI_SIEVERT", 62);
			LeaveRule("SI_SIEVERT", 62);
			LeaveRule_SI_SIEVERT();
		}
	}
	// $ANTLR end "SI_SIEVERT"

	partial void EnterRule_SI_KATAL();
	partial void LeaveRule_SI_KATAL();

	// $ANTLR start "SI_KATAL"
	[GrammarRule("SI_KATAL")]
	private void mSI_KATAL()
	{
		EnterRule_SI_KATAL();
		EnterRule("SI_KATAL", 63);
		TraceIn("SI_KATAL", 63);
		try
		{
			// formula.g:154:18: ( 'kat' )
			DebugEnterAlt(1);
			// formula.g:154:20: 'kat'
			{
			DebugLocation(154, 20);
			Match("kat"); 


			}

		}
		finally
		{
			TraceOut("SI_KATAL", 63);
			LeaveRule("SI_KATAL", 63);
			LeaveRule_SI_KATAL();
		}
	}
	// $ANTLR end "SI_KATAL"

	partial void EnterRule_SI_PASCAL_SEC();
	partial void LeaveRule_SI_PASCAL_SEC();

	// $ANTLR start "SI_PASCAL_SEC"
	[GrammarRule("SI_PASCAL_SEC")]
	private void mSI_PASCAL_SEC()
	{
		EnterRule_SI_PASCAL_SEC();
		EnterRule("SI_PASCAL_SEC", 64);
		TraceIn("SI_PASCAL_SEC", 64);
		try
		{
			// formula.g:155:23: ( 'Pa·s' )
			DebugEnterAlt(1);
			// formula.g:155:25: 'Pa·s'
			{
			DebugLocation(155, 25);
			Match("Pa·s"); 


			}

		}
		finally
		{
			TraceOut("SI_PASCAL_SEC", 64);
			LeaveRule("SI_PASCAL_SEC", 64);
			LeaveRule_SI_PASCAL_SEC();
		}
	}
	// $ANTLR end "SI_PASCAL_SEC"

	partial void EnterRule_SI_NEWTON_METER();
	partial void LeaveRule_SI_NEWTON_METER();

	// $ANTLR start "SI_NEWTON_METER"
	[GrammarRule("SI_NEWTON_METER")]
	private void mSI_NEWTON_METER()
	{
		EnterRule_SI_NEWTON_METER();
		EnterRule("SI_NEWTON_METER", 65);
		TraceIn("SI_NEWTON_METER", 65);
		try
		{
			// formula.g:156:25: ( 'N·m' )
			DebugEnterAlt(1);
			// formula.g:156:27: 'N·m'
			{
			DebugLocation(156, 27);
			Match("N·m"); 


			}

		}
		finally
		{
			TraceOut("SI_NEWTON_METER", 65);
			LeaveRule("SI_NEWTON_METER", 65);
			LeaveRule_SI_NEWTON_METER();
		}
	}
	// $ANTLR end "SI_NEWTON_METER"

	partial void EnterRule_SI_NEWTON_PER_METER();
	partial void LeaveRule_SI_NEWTON_PER_METER();

	// $ANTLR start "SI_NEWTON_PER_METER"
	[GrammarRule("SI_NEWTON_PER_METER")]
	private void mSI_NEWTON_PER_METER()
	{
		EnterRule_SI_NEWTON_PER_METER();
		EnterRule("SI_NEWTON_PER_METER", 66);
		TraceIn("SI_NEWTON_PER_METER", 66);
		try
		{
			// formula.g:157:29: ( 'N/m' )
			DebugEnterAlt(1);
			// formula.g:157:31: 'N/m'
			{
			DebugLocation(157, 31);
			Match("N/m"); 


			}

		}
		finally
		{
			TraceOut("SI_NEWTON_PER_METER", 66);
			LeaveRule("SI_NEWTON_PER_METER", 66);
			LeaveRule_SI_NEWTON_PER_METER();
		}
	}
	// $ANTLR end "SI_NEWTON_PER_METER"

	partial void EnterRule_SI_RADIAN_PER_SEC();
	partial void LeaveRule_SI_RADIAN_PER_SEC();

	// $ANTLR start "SI_RADIAN_PER_SEC"
	[GrammarRule("SI_RADIAN_PER_SEC")]
	private void mSI_RADIAN_PER_SEC()
	{
		EnterRule_SI_RADIAN_PER_SEC();
		EnterRule("SI_RADIAN_PER_SEC", 67);
		TraceIn("SI_RADIAN_PER_SEC", 67);
		try
		{
			// formula.g:158:27: ( 'rad/s' )
			DebugEnterAlt(1);
			// formula.g:158:29: 'rad/s'
			{
			DebugLocation(158, 29);
			Match("rad/s"); 


			}

		}
		finally
		{
			TraceOut("SI_RADIAN_PER_SEC", 67);
			LeaveRule("SI_RADIAN_PER_SEC", 67);
			LeaveRule_SI_RADIAN_PER_SEC();
		}
	}
	// $ANTLR end "SI_RADIAN_PER_SEC"

	partial void EnterRule_SI_RADIAN_PER_SEC_SQ_1();
	partial void LeaveRule_SI_RADIAN_PER_SEC_SQ_1();

	// $ANTLR start "SI_RADIAN_PER_SEC_SQ_1"
	[GrammarRule("SI_RADIAN_PER_SEC_SQ_1")]
	private void mSI_RADIAN_PER_SEC_SQ_1()
	{
		EnterRule_SI_RADIAN_PER_SEC_SQ_1();
		EnterRule("SI_RADIAN_PER_SEC_SQ_1", 68);
		TraceIn("SI_RADIAN_PER_SEC_SQ_1", 68);
		try
		{
			// formula.g:159:32: ( 'rad/s²' )
			DebugEnterAlt(1);
			// formula.g:159:34: 'rad/s²'
			{
			DebugLocation(159, 34);
			Match("rad/s²"); 


			}

		}
		finally
		{
			TraceOut("SI_RADIAN_PER_SEC_SQ_1", 68);
			LeaveRule("SI_RADIAN_PER_SEC_SQ_1", 68);
			LeaveRule_SI_RADIAN_PER_SEC_SQ_1();
		}
	}
	// $ANTLR end "SI_RADIAN_PER_SEC_SQ_1"

	partial void EnterRule_SI_RADIAN_PER_SEC_SQ_2();
	partial void LeaveRule_SI_RADIAN_PER_SEC_SQ_2();

	// $ANTLR start "SI_RADIAN_PER_SEC_SQ_2"
	[GrammarRule("SI_RADIAN_PER_SEC_SQ_2")]
	private void mSI_RADIAN_PER_SEC_SQ_2()
	{
		EnterRule_SI_RADIAN_PER_SEC_SQ_2();
		EnterRule("SI_RADIAN_PER_SEC_SQ_2", 69);
		TraceIn("SI_RADIAN_PER_SEC_SQ_2", 69);
		try
		{
			// formula.g:160:32: ( 'rad/s^2' )
			DebugEnterAlt(1);
			// formula.g:160:34: 'rad/s^2'
			{
			DebugLocation(160, 34);
			Match("rad/s^2"); 


			}

		}
		finally
		{
			TraceOut("SI_RADIAN_PER_SEC_SQ_2", 69);
			LeaveRule("SI_RADIAN_PER_SEC_SQ_2", 69);
			LeaveRule_SI_RADIAN_PER_SEC_SQ_2();
		}
	}
	// $ANTLR end "SI_RADIAN_PER_SEC_SQ_2"

	partial void EnterRule_SI_WATT_PER_METER_SQ_1();
	partial void LeaveRule_SI_WATT_PER_METER_SQ_1();

	// $ANTLR start "SI_WATT_PER_METER_SQ_1"
	[GrammarRule("SI_WATT_PER_METER_SQ_1")]
	private void mSI_WATT_PER_METER_SQ_1()
	{
		EnterRule_SI_WATT_PER_METER_SQ_1();
		EnterRule("SI_WATT_PER_METER_SQ_1", 70);
		TraceIn("SI_WATT_PER_METER_SQ_1", 70);
		try
		{
			// formula.g:161:32: ( 'W/m²' )
			DebugEnterAlt(1);
			// formula.g:161:34: 'W/m²'
			{
			DebugLocation(161, 34);
			Match("W/m²"); 


			}

		}
		finally
		{
			TraceOut("SI_WATT_PER_METER_SQ_1", 70);
			LeaveRule("SI_WATT_PER_METER_SQ_1", 70);
			LeaveRule_SI_WATT_PER_METER_SQ_1();
		}
	}
	// $ANTLR end "SI_WATT_PER_METER_SQ_1"

	partial void EnterRule_SI_WATT_PER_METER_SQ_2();
	partial void LeaveRule_SI_WATT_PER_METER_SQ_2();

	// $ANTLR start "SI_WATT_PER_METER_SQ_2"
	[GrammarRule("SI_WATT_PER_METER_SQ_2")]
	private void mSI_WATT_PER_METER_SQ_2()
	{
		EnterRule_SI_WATT_PER_METER_SQ_2();
		EnterRule("SI_WATT_PER_METER_SQ_2", 71);
		TraceIn("SI_WATT_PER_METER_SQ_2", 71);
		try
		{
			// formula.g:162:32: ( 'W/m^2' )
			DebugEnterAlt(1);
			// formula.g:162:34: 'W/m^2'
			{
			DebugLocation(162, 34);
			Match("W/m^2"); 


			}

		}
		finally
		{
			TraceOut("SI_WATT_PER_METER_SQ_2", 71);
			LeaveRule("SI_WATT_PER_METER_SQ_2", 71);
			LeaveRule_SI_WATT_PER_METER_SQ_2();
		}
	}
	// $ANTLR end "SI_WATT_PER_METER_SQ_2"

	partial void EnterRule_SI_JOULE_PER_KELVIN();
	partial void LeaveRule_SI_JOULE_PER_KELVIN();

	// $ANTLR start "SI_JOULE_PER_KELVIN"
	[GrammarRule("SI_JOULE_PER_KELVIN")]
	private void mSI_JOULE_PER_KELVIN()
	{
		EnterRule_SI_JOULE_PER_KELVIN();
		EnterRule("SI_JOULE_PER_KELVIN", 72);
		TraceIn("SI_JOULE_PER_KELVIN", 72);
		try
		{
			// formula.g:163:29: ( 'J/K' )
			DebugEnterAlt(1);
			// formula.g:163:31: 'J/K'
			{
			DebugLocation(163, 31);
			Match("J/K"); 


			}

		}
		finally
		{
			TraceOut("SI_JOULE_PER_KELVIN", 72);
			LeaveRule("SI_JOULE_PER_KELVIN", 72);
			LeaveRule_SI_JOULE_PER_KELVIN();
		}
	}
	// $ANTLR end "SI_JOULE_PER_KELVIN"

	partial void EnterRule_SI_JOULE_PER_KG_KELVIN();
	partial void LeaveRule_SI_JOULE_PER_KG_KELVIN();

	// $ANTLR start "SI_JOULE_PER_KG_KELVIN"
	[GrammarRule("SI_JOULE_PER_KG_KELVIN")]
	private void mSI_JOULE_PER_KG_KELVIN()
	{
		EnterRule_SI_JOULE_PER_KG_KELVIN();
		EnterRule("SI_JOULE_PER_KG_KELVIN", 73);
		TraceIn("SI_JOULE_PER_KG_KELVIN", 73);
		try
		{
			// formula.g:164:32: ( 'J/(kg·K)' )
			DebugEnterAlt(1);
			// formula.g:164:34: 'J/(kg·K)'
			{
			DebugLocation(164, 34);
			Match("J/(kg·K)"); 


			}

		}
		finally
		{
			TraceOut("SI_JOULE_PER_KG_KELVIN", 73);
			LeaveRule("SI_JOULE_PER_KG_KELVIN", 73);
			LeaveRule_SI_JOULE_PER_KG_KELVIN();
		}
	}
	// $ANTLR end "SI_JOULE_PER_KG_KELVIN"

	partial void EnterRule_SI_JOULE_PER_KG();
	partial void LeaveRule_SI_JOULE_PER_KG();

	// $ANTLR start "SI_JOULE_PER_KG"
	[GrammarRule("SI_JOULE_PER_KG")]
	private void mSI_JOULE_PER_KG()
	{
		EnterRule_SI_JOULE_PER_KG();
		EnterRule("SI_JOULE_PER_KG", 74);
		TraceIn("SI_JOULE_PER_KG", 74);
		try
		{
			// formula.g:165:25: ( 'J/kg' )
			DebugEnterAlt(1);
			// formula.g:165:27: 'J/kg'
			{
			DebugLocation(165, 27);
			Match("J/kg"); 


			}

		}
		finally
		{
			TraceOut("SI_JOULE_PER_KG", 74);
			LeaveRule("SI_JOULE_PER_KG", 74);
			LeaveRule_SI_JOULE_PER_KG();
		}
	}
	// $ANTLR end "SI_JOULE_PER_KG"

	partial void EnterRule_SI_WATT_PER_METER_KELVIN();
	partial void LeaveRule_SI_WATT_PER_METER_KELVIN();

	// $ANTLR start "SI_WATT_PER_METER_KELVIN"
	[GrammarRule("SI_WATT_PER_METER_KELVIN")]
	private void mSI_WATT_PER_METER_KELVIN()
	{
		EnterRule_SI_WATT_PER_METER_KELVIN();
		EnterRule("SI_WATT_PER_METER_KELVIN", 75);
		TraceIn("SI_WATT_PER_METER_KELVIN", 75);
		try
		{
			// formula.g:166:34: ( 'W/(m·K)' )
			DebugEnterAlt(1);
			// formula.g:166:36: 'W/(m·K)'
			{
			DebugLocation(166, 36);
			Match("W/(m·K)"); 


			}

		}
		finally
		{
			TraceOut("SI_WATT_PER_METER_KELVIN", 75);
			LeaveRule("SI_WATT_PER_METER_KELVIN", 75);
			LeaveRule_SI_WATT_PER_METER_KELVIN();
		}
	}
	// $ANTLR end "SI_WATT_PER_METER_KELVIN"

	partial void EnterRule_SI_JOULE_PER_CU_METER_1();
	partial void LeaveRule_SI_JOULE_PER_CU_METER_1();

	// $ANTLR start "SI_JOULE_PER_CU_METER_1"
	[GrammarRule("SI_JOULE_PER_CU_METER_1")]
	private void mSI_JOULE_PER_CU_METER_1()
	{
		EnterRule_SI_JOULE_PER_CU_METER_1();
		EnterRule("SI_JOULE_PER_CU_METER_1", 76);
		TraceIn("SI_JOULE_PER_CU_METER_1", 76);
		try
		{
			// formula.g:167:33: ( 'J/m³' )
			DebugEnterAlt(1);
			// formula.g:167:35: 'J/m³'
			{
			DebugLocation(167, 35);
			Match("J/m³"); 


			}

		}
		finally
		{
			TraceOut("SI_JOULE_PER_CU_METER_1", 76);
			LeaveRule("SI_JOULE_PER_CU_METER_1", 76);
			LeaveRule_SI_JOULE_PER_CU_METER_1();
		}
	}
	// $ANTLR end "SI_JOULE_PER_CU_METER_1"

	partial void EnterRule_SI_JOULE_PER_CU_METER_2();
	partial void LeaveRule_SI_JOULE_PER_CU_METER_2();

	// $ANTLR start "SI_JOULE_PER_CU_METER_2"
	[GrammarRule("SI_JOULE_PER_CU_METER_2")]
	private void mSI_JOULE_PER_CU_METER_2()
	{
		EnterRule_SI_JOULE_PER_CU_METER_2();
		EnterRule("SI_JOULE_PER_CU_METER_2", 77);
		TraceIn("SI_JOULE_PER_CU_METER_2", 77);
		try
		{
			// formula.g:168:33: ( 'J/m^3' )
			DebugEnterAlt(1);
			// formula.g:168:35: 'J/m^3'
			{
			DebugLocation(168, 35);
			Match("J/m^3"); 


			}

		}
		finally
		{
			TraceOut("SI_JOULE_PER_CU_METER_2", 77);
			LeaveRule("SI_JOULE_PER_CU_METER_2", 77);
			LeaveRule_SI_JOULE_PER_CU_METER_2();
		}
	}
	// $ANTLR end "SI_JOULE_PER_CU_METER_2"

	partial void EnterRule_SI_VOLT_PER_METER();
	partial void LeaveRule_SI_VOLT_PER_METER();

	// $ANTLR start "SI_VOLT_PER_METER"
	[GrammarRule("SI_VOLT_PER_METER")]
	private void mSI_VOLT_PER_METER()
	{
		EnterRule_SI_VOLT_PER_METER();
		EnterRule("SI_VOLT_PER_METER", 78);
		TraceIn("SI_VOLT_PER_METER", 78);
		try
		{
			// formula.g:169:27: ( 'V/m' )
			DebugEnterAlt(1);
			// formula.g:169:29: 'V/m'
			{
			DebugLocation(169, 29);
			Match("V/m"); 


			}

		}
		finally
		{
			TraceOut("SI_VOLT_PER_METER", 78);
			LeaveRule("SI_VOLT_PER_METER", 78);
			LeaveRule_SI_VOLT_PER_METER();
		}
	}
	// $ANTLR end "SI_VOLT_PER_METER"

	partial void EnterRule_SI_COULOMB_PER_CU_METER_1();
	partial void LeaveRule_SI_COULOMB_PER_CU_METER_1();

	// $ANTLR start "SI_COULOMB_PER_CU_METER_1"
	[GrammarRule("SI_COULOMB_PER_CU_METER_1")]
	private void mSI_COULOMB_PER_CU_METER_1()
	{
		EnterRule_SI_COULOMB_PER_CU_METER_1();
		EnterRule("SI_COULOMB_PER_CU_METER_1", 79);
		TraceIn("SI_COULOMB_PER_CU_METER_1", 79);
		try
		{
			// formula.g:170:35: ( 'C/m³' )
			DebugEnterAlt(1);
			// formula.g:170:37: 'C/m³'
			{
			DebugLocation(170, 37);
			Match("C/m³"); 


			}

		}
		finally
		{
			TraceOut("SI_COULOMB_PER_CU_METER_1", 79);
			LeaveRule("SI_COULOMB_PER_CU_METER_1", 79);
			LeaveRule_SI_COULOMB_PER_CU_METER_1();
		}
	}
	// $ANTLR end "SI_COULOMB_PER_CU_METER_1"

	partial void EnterRule_SI_COULOMB_PER_CU_METER_2();
	partial void LeaveRule_SI_COULOMB_PER_CU_METER_2();

	// $ANTLR start "SI_COULOMB_PER_CU_METER_2"
	[GrammarRule("SI_COULOMB_PER_CU_METER_2")]
	private void mSI_COULOMB_PER_CU_METER_2()
	{
		EnterRule_SI_COULOMB_PER_CU_METER_2();
		EnterRule("SI_COULOMB_PER_CU_METER_2", 80);
		TraceIn("SI_COULOMB_PER_CU_METER_2", 80);
		try
		{
			// formula.g:171:35: ( 'C/m^3' )
			DebugEnterAlt(1);
			// formula.g:171:37: 'C/m^3'
			{
			DebugLocation(171, 37);
			Match("C/m^3"); 


			}

		}
		finally
		{
			TraceOut("SI_COULOMB_PER_CU_METER_2", 80);
			LeaveRule("SI_COULOMB_PER_CU_METER_2", 80);
			LeaveRule_SI_COULOMB_PER_CU_METER_2();
		}
	}
	// $ANTLR end "SI_COULOMB_PER_CU_METER_2"

	partial void EnterRule_SI_COULOMB_PER_SQ_METER_1();
	partial void LeaveRule_SI_COULOMB_PER_SQ_METER_1();

	// $ANTLR start "SI_COULOMB_PER_SQ_METER_1"
	[GrammarRule("SI_COULOMB_PER_SQ_METER_1")]
	private void mSI_COULOMB_PER_SQ_METER_1()
	{
		EnterRule_SI_COULOMB_PER_SQ_METER_1();
		EnterRule("SI_COULOMB_PER_SQ_METER_1", 81);
		TraceIn("SI_COULOMB_PER_SQ_METER_1", 81);
		try
		{
			// formula.g:172:35: ( 'C/m²' )
			DebugEnterAlt(1);
			// formula.g:172:37: 'C/m²'
			{
			DebugLocation(172, 37);
			Match("C/m²"); 


			}

		}
		finally
		{
			TraceOut("SI_COULOMB_PER_SQ_METER_1", 81);
			LeaveRule("SI_COULOMB_PER_SQ_METER_1", 81);
			LeaveRule_SI_COULOMB_PER_SQ_METER_1();
		}
	}
	// $ANTLR end "SI_COULOMB_PER_SQ_METER_1"

	partial void EnterRule_SI_COULOMB_PER_SQ_METER_2();
	partial void LeaveRule_SI_COULOMB_PER_SQ_METER_2();

	// $ANTLR start "SI_COULOMB_PER_SQ_METER_2"
	[GrammarRule("SI_COULOMB_PER_SQ_METER_2")]
	private void mSI_COULOMB_PER_SQ_METER_2()
	{
		EnterRule_SI_COULOMB_PER_SQ_METER_2();
		EnterRule("SI_COULOMB_PER_SQ_METER_2", 82);
		TraceIn("SI_COULOMB_PER_SQ_METER_2", 82);
		try
		{
			// formula.g:173:35: ( 'C/m^2' )
			DebugEnterAlt(1);
			// formula.g:173:37: 'C/m^2'
			{
			DebugLocation(173, 37);
			Match("C/m^2"); 


			}

		}
		finally
		{
			TraceOut("SI_COULOMB_PER_SQ_METER_2", 82);
			LeaveRule("SI_COULOMB_PER_SQ_METER_2", 82);
			LeaveRule_SI_COULOMB_PER_SQ_METER_2();
		}
	}
	// $ANTLR end "SI_COULOMB_PER_SQ_METER_2"

	partial void EnterRule_SI_FARAD_PER_METER();
	partial void LeaveRule_SI_FARAD_PER_METER();

	// $ANTLR start "SI_FARAD_PER_METER"
	[GrammarRule("SI_FARAD_PER_METER")]
	private void mSI_FARAD_PER_METER()
	{
		EnterRule_SI_FARAD_PER_METER();
		EnterRule("SI_FARAD_PER_METER", 83);
		TraceIn("SI_FARAD_PER_METER", 83);
		try
		{
			// formula.g:174:28: ( 'F/m' )
			DebugEnterAlt(1);
			// formula.g:174:30: 'F/m'
			{
			DebugLocation(174, 30);
			Match("F/m"); 


			}

		}
		finally
		{
			TraceOut("SI_FARAD_PER_METER", 83);
			LeaveRule("SI_FARAD_PER_METER", 83);
			LeaveRule_SI_FARAD_PER_METER();
		}
	}
	// $ANTLR end "SI_FARAD_PER_METER"

	partial void EnterRule_SI_HENRY_PER_METER();
	partial void LeaveRule_SI_HENRY_PER_METER();

	// $ANTLR start "SI_HENRY_PER_METER"
	[GrammarRule("SI_HENRY_PER_METER")]
	private void mSI_HENRY_PER_METER()
	{
		EnterRule_SI_HENRY_PER_METER();
		EnterRule("SI_HENRY_PER_METER", 84);
		TraceIn("SI_HENRY_PER_METER", 84);
		try
		{
			// formula.g:175:28: ( 'H/m' )
			DebugEnterAlt(1);
			// formula.g:175:30: 'H/m'
			{
			DebugLocation(175, 30);
			Match("H/m"); 


			}

		}
		finally
		{
			TraceOut("SI_HENRY_PER_METER", 84);
			LeaveRule("SI_HENRY_PER_METER", 84);
			LeaveRule_SI_HENRY_PER_METER();
		}
	}
	// $ANTLR end "SI_HENRY_PER_METER"

	partial void EnterRule_SI_JOULE_PER_MOLE();
	partial void LeaveRule_SI_JOULE_PER_MOLE();

	// $ANTLR start "SI_JOULE_PER_MOLE"
	[GrammarRule("SI_JOULE_PER_MOLE")]
	private void mSI_JOULE_PER_MOLE()
	{
		EnterRule_SI_JOULE_PER_MOLE();
		EnterRule("SI_JOULE_PER_MOLE", 85);
		TraceIn("SI_JOULE_PER_MOLE", 85);
		try
		{
			// formula.g:176:27: ( 'J/mol' )
			DebugEnterAlt(1);
			// formula.g:176:29: 'J/mol'
			{
			DebugLocation(176, 29);
			Match("J/mol"); 


			}

		}
		finally
		{
			TraceOut("SI_JOULE_PER_MOLE", 85);
			LeaveRule("SI_JOULE_PER_MOLE", 85);
			LeaveRule_SI_JOULE_PER_MOLE();
		}
	}
	// $ANTLR end "SI_JOULE_PER_MOLE"

	partial void EnterRule_SI_JOULE_PER_MOLE_KELVIN();
	partial void LeaveRule_SI_JOULE_PER_MOLE_KELVIN();

	// $ANTLR start "SI_JOULE_PER_MOLE_KELVIN"
	[GrammarRule("SI_JOULE_PER_MOLE_KELVIN")]
	private void mSI_JOULE_PER_MOLE_KELVIN()
	{
		EnterRule_SI_JOULE_PER_MOLE_KELVIN();
		EnterRule("SI_JOULE_PER_MOLE_KELVIN", 86);
		TraceIn("SI_JOULE_PER_MOLE_KELVIN", 86);
		try
		{
			// formula.g:177:34: ( 'J/(mol·K)' )
			DebugEnterAlt(1);
			// formula.g:177:36: 'J/(mol·K)'
			{
			DebugLocation(177, 36);
			Match("J/(mol·K)"); 


			}

		}
		finally
		{
			TraceOut("SI_JOULE_PER_MOLE_KELVIN", 86);
			LeaveRule("SI_JOULE_PER_MOLE_KELVIN", 86);
			LeaveRule_SI_JOULE_PER_MOLE_KELVIN();
		}
	}
	// $ANTLR end "SI_JOULE_PER_MOLE_KELVIN"

	partial void EnterRule_SI_COULOMB_PER_KG();
	partial void LeaveRule_SI_COULOMB_PER_KG();

	// $ANTLR start "SI_COULOMB_PER_KG"
	[GrammarRule("SI_COULOMB_PER_KG")]
	private void mSI_COULOMB_PER_KG()
	{
		EnterRule_SI_COULOMB_PER_KG();
		EnterRule("SI_COULOMB_PER_KG", 87);
		TraceIn("SI_COULOMB_PER_KG", 87);
		try
		{
			// formula.g:178:27: ( 'C/kg' )
			DebugEnterAlt(1);
			// formula.g:178:29: 'C/kg'
			{
			DebugLocation(178, 29);
			Match("C/kg"); 


			}

		}
		finally
		{
			TraceOut("SI_COULOMB_PER_KG", 87);
			LeaveRule("SI_COULOMB_PER_KG", 87);
			LeaveRule_SI_COULOMB_PER_KG();
		}
	}
	// $ANTLR end "SI_COULOMB_PER_KG"

	partial void EnterRule_SI_GRAY_PER_SEC();
	partial void LeaveRule_SI_GRAY_PER_SEC();

	// $ANTLR start "SI_GRAY_PER_SEC"
	[GrammarRule("SI_GRAY_PER_SEC")]
	private void mSI_GRAY_PER_SEC()
	{
		EnterRule_SI_GRAY_PER_SEC();
		EnterRule("SI_GRAY_PER_SEC", 88);
		TraceIn("SI_GRAY_PER_SEC", 88);
		try
		{
			// formula.g:179:25: ( 'Gy/s' )
			DebugEnterAlt(1);
			// formula.g:179:27: 'Gy/s'
			{
			DebugLocation(179, 27);
			Match("Gy/s"); 


			}

		}
		finally
		{
			TraceOut("SI_GRAY_PER_SEC", 88);
			LeaveRule("SI_GRAY_PER_SEC", 88);
			LeaveRule_SI_GRAY_PER_SEC();
		}
	}
	// $ANTLR end "SI_GRAY_PER_SEC"

	partial void EnterRule_SI_WATT_PER_STERADIAN();
	partial void LeaveRule_SI_WATT_PER_STERADIAN();

	// $ANTLR start "SI_WATT_PER_STERADIAN"
	[GrammarRule("SI_WATT_PER_STERADIAN")]
	private void mSI_WATT_PER_STERADIAN()
	{
		EnterRule_SI_WATT_PER_STERADIAN();
		EnterRule("SI_WATT_PER_STERADIAN", 89);
		TraceIn("SI_WATT_PER_STERADIAN", 89);
		try
		{
			// formula.g:180:31: ( 'W/sr' )
			DebugEnterAlt(1);
			// formula.g:180:33: 'W/sr'
			{
			DebugLocation(180, 33);
			Match("W/sr"); 


			}

		}
		finally
		{
			TraceOut("SI_WATT_PER_STERADIAN", 89);
			LeaveRule("SI_WATT_PER_STERADIAN", 89);
			LeaveRule_SI_WATT_PER_STERADIAN();
		}
	}
	// $ANTLR end "SI_WATT_PER_STERADIAN"

	partial void EnterRule_SI_WATT_PER_SQ_METER_STERADIAN_1();
	partial void LeaveRule_SI_WATT_PER_SQ_METER_STERADIAN_1();

	// $ANTLR start "SI_WATT_PER_SQ_METER_STERADIAN_1"
	[GrammarRule("SI_WATT_PER_SQ_METER_STERADIAN_1")]
	private void mSI_WATT_PER_SQ_METER_STERADIAN_1()
	{
		EnterRule_SI_WATT_PER_SQ_METER_STERADIAN_1();
		EnterRule("SI_WATT_PER_SQ_METER_STERADIAN_1", 90);
		TraceIn("SI_WATT_PER_SQ_METER_STERADIAN_1", 90);
		try
		{
			// formula.g:181:42: ( 'W/(m²·sr)' )
			DebugEnterAlt(1);
			// formula.g:181:44: 'W/(m²·sr)'
			{
			DebugLocation(181, 44);
			Match("W/(m²·sr)"); 


			}

		}
		finally
		{
			TraceOut("SI_WATT_PER_SQ_METER_STERADIAN_1", 90);
			LeaveRule("SI_WATT_PER_SQ_METER_STERADIAN_1", 90);
			LeaveRule_SI_WATT_PER_SQ_METER_STERADIAN_1();
		}
	}
	// $ANTLR end "SI_WATT_PER_SQ_METER_STERADIAN_1"

	partial void EnterRule_SI_WATT_PER_SQ_METER_STERADIAN_2();
	partial void LeaveRule_SI_WATT_PER_SQ_METER_STERADIAN_2();

	// $ANTLR start "SI_WATT_PER_SQ_METER_STERADIAN_2"
	[GrammarRule("SI_WATT_PER_SQ_METER_STERADIAN_2")]
	private void mSI_WATT_PER_SQ_METER_STERADIAN_2()
	{
		EnterRule_SI_WATT_PER_SQ_METER_STERADIAN_2();
		EnterRule("SI_WATT_PER_SQ_METER_STERADIAN_2", 91);
		TraceIn("SI_WATT_PER_SQ_METER_STERADIAN_2", 91);
		try
		{
			// formula.g:182:42: ( 'W/(m^2·sr)' )
			DebugEnterAlt(1);
			// formula.g:182:44: 'W/(m^2·sr)'
			{
			DebugLocation(182, 44);
			Match("W/(m^2·sr)"); 


			}

		}
		finally
		{
			TraceOut("SI_WATT_PER_SQ_METER_STERADIAN_2", 91);
			LeaveRule("SI_WATT_PER_SQ_METER_STERADIAN_2", 91);
			LeaveRule_SI_WATT_PER_SQ_METER_STERADIAN_2();
		}
	}
	// $ANTLR end "SI_WATT_PER_SQ_METER_STERADIAN_2"

	partial void EnterRule_SI_KATAL_PER_CU_METER_1();
	partial void LeaveRule_SI_KATAL_PER_CU_METER_1();

	// $ANTLR start "SI_KATAL_PER_CU_METER_1"
	[GrammarRule("SI_KATAL_PER_CU_METER_1")]
	private void mSI_KATAL_PER_CU_METER_1()
	{
		EnterRule_SI_KATAL_PER_CU_METER_1();
		EnterRule("SI_KATAL_PER_CU_METER_1", 92);
		TraceIn("SI_KATAL_PER_CU_METER_1", 92);
		try
		{
			// formula.g:183:33: ( 'kat/m³' )
			DebugEnterAlt(1);
			// formula.g:183:35: 'kat/m³'
			{
			DebugLocation(183, 35);
			Match("kat/m³"); 


			}

		}
		finally
		{
			TraceOut("SI_KATAL_PER_CU_METER_1", 92);
			LeaveRule("SI_KATAL_PER_CU_METER_1", 92);
			LeaveRule_SI_KATAL_PER_CU_METER_1();
		}
	}
	// $ANTLR end "SI_KATAL_PER_CU_METER_1"

	partial void EnterRule_SI_KATAL_PER_CU_METER_2();
	partial void LeaveRule_SI_KATAL_PER_CU_METER_2();

	// $ANTLR start "SI_KATAL_PER_CU_METER_2"
	[GrammarRule("SI_KATAL_PER_CU_METER_2")]
	private void mSI_KATAL_PER_CU_METER_2()
	{
		EnterRule_SI_KATAL_PER_CU_METER_2();
		EnterRule("SI_KATAL_PER_CU_METER_2", 93);
		TraceIn("SI_KATAL_PER_CU_METER_2", 93);
		try
		{
			// formula.g:184:33: ( 'kat/m^3' )
			DebugEnterAlt(1);
			// formula.g:184:35: 'kat/m^3'
			{
			DebugLocation(184, 35);
			Match("kat/m^3"); 


			}

		}
		finally
		{
			TraceOut("SI_KATAL_PER_CU_METER_2", 93);
			LeaveRule("SI_KATAL_PER_CU_METER_2", 93);
			LeaveRule_SI_KATAL_PER_CU_METER_2();
		}
	}
	// $ANTLR end "SI_KATAL_PER_CU_METER_2"

	partial void EnterRule_CURR_SYM();
	partial void LeaveRule_CURR_SYM();

	// $ANTLR start "CURR_SYM"
	[GrammarRule("CURR_SYM")]
	private void mCURR_SYM()
	{
		EnterRule_CURR_SYM();
		EnterRule("CURR_SYM", 94);
		TraceIn("CURR_SYM", 94);
		try
		{
			// formula.g:189:5: ( ( CURR_ALL | CURR_AFN | CURR_USD | CURR_AWG | CURR_AZN | CURR_BYR | CURR_BZD | CURR_BOB | CURR_BAM | CURR_BWP | CURR_BGN | CURR_BRL | CURR_KHR | CURR_CRC | CURR_HRK | CURR_CUP | CURR_CZK | CURR_DKK | CURR_DOP | CURR_GBP | CURR_EUR | CURR_GHS | CURR_GTQ | CURR_HNL | CURR_HUF | CURR_IDR | CURR_IRR | CURR_ILS | CURR_JMD | CURR_JPY | CURR_LAK | CURR_MKD | CURR_MYR | CURR_MNT | CURR_MZN | CURR_NIO | CURR_NGN | CURR_PAB | CURR_PYG | CURR_PEN | CURR_PLN | CURR_RON | CURR_RUB | CURR_RSD | CURR_SOS | CURR_ZAR | CURR_CHF | CURR_TWD | CURR_THB | CURR_TTD | CURR_UAH | CURR_UYU | CURR_VEF | CURR_VND | CURR_ZWD | CURR_XBT ) )
			DebugEnterAlt(1);
			// formula.g:189:9: ( CURR_ALL | CURR_AFN | CURR_USD | CURR_AWG | CURR_AZN | CURR_BYR | CURR_BZD | CURR_BOB | CURR_BAM | CURR_BWP | CURR_BGN | CURR_BRL | CURR_KHR | CURR_CRC | CURR_HRK | CURR_CUP | CURR_CZK | CURR_DKK | CURR_DOP | CURR_GBP | CURR_EUR | CURR_GHS | CURR_GTQ | CURR_HNL | CURR_HUF | CURR_IDR | CURR_IRR | CURR_ILS | CURR_JMD | CURR_JPY | CURR_LAK | CURR_MKD | CURR_MYR | CURR_MNT | CURR_MZN | CURR_NIO | CURR_NGN | CURR_PAB | CURR_PYG | CURR_PEN | CURR_PLN | CURR_RON | CURR_RUB | CURR_RSD | CURR_SOS | CURR_ZAR | CURR_CHF | CURR_TWD | CURR_THB | CURR_TTD | CURR_UAH | CURR_UYU | CURR_VEF | CURR_VND | CURR_ZWD | CURR_XBT )
			{
			DebugLocation(189, 9);
			// formula.g:189:9: ( CURR_ALL | CURR_AFN | CURR_USD | CURR_AWG | CURR_AZN | CURR_BYR | CURR_BZD | CURR_BOB | CURR_BAM | CURR_BWP | CURR_BGN | CURR_BRL | CURR_KHR | CURR_CRC | CURR_HRK | CURR_CUP | CURR_CZK | CURR_DKK | CURR_DOP | CURR_GBP | CURR_EUR | CURR_GHS | CURR_GTQ | CURR_HNL | CURR_HUF | CURR_IDR | CURR_IRR | CURR_ILS | CURR_JMD | CURR_JPY | CURR_LAK | CURR_MKD | CURR_MYR | CURR_MNT | CURR_MZN | CURR_NIO | CURR_NGN | CURR_PAB | CURR_PYG | CURR_PEN | CURR_PLN | CURR_RON | CURR_RUB | CURR_RSD | CURR_SOS | CURR_ZAR | CURR_CHF | CURR_TWD | CURR_THB | CURR_TTD | CURR_UAH | CURR_UYU | CURR_VEF | CURR_VND | CURR_ZWD | CURR_XBT )
			int alt24=56;
			try { DebugEnterSubRule(24);
			try { DebugEnterDecision(24, false);
			try
			{
				alt24 = dfa24.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(24); }
			switch (alt24)
			{
			case 1:
				DebugEnterAlt(1);
				// formula.g:189:10: CURR_ALL
				{
				DebugLocation(189, 10);
				mCURR_ALL(); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// formula.g:189:19: CURR_AFN
				{
				DebugLocation(189, 19);
				mCURR_AFN(); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// formula.g:189:28: CURR_USD
				{
				DebugLocation(189, 28);
				mCURR_USD(); 

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// formula.g:189:37: CURR_AWG
				{
				DebugLocation(189, 37);
				mCURR_AWG(); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// formula.g:189:46: CURR_AZN
				{
				DebugLocation(189, 46);
				mCURR_AZN(); 

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// formula.g:189:55: CURR_BYR
				{
				DebugLocation(189, 55);
				mCURR_BYR(); 

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// formula.g:189:64: CURR_BZD
				{
				DebugLocation(189, 64);
				mCURR_BZD(); 

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// formula.g:190:6: CURR_BOB
				{
				DebugLocation(190, 6);
				mCURR_BOB(); 

				}
				break;
			case 9:
				DebugEnterAlt(9);
				// formula.g:190:15: CURR_BAM
				{
				DebugLocation(190, 15);
				mCURR_BAM(); 

				}
				break;
			case 10:
				DebugEnterAlt(10);
				// formula.g:190:24: CURR_BWP
				{
				DebugLocation(190, 24);
				mCURR_BWP(); 

				}
				break;
			case 11:
				DebugEnterAlt(11);
				// formula.g:190:33: CURR_BGN
				{
				DebugLocation(190, 33);
				mCURR_BGN(); 

				}
				break;
			case 12:
				DebugEnterAlt(12);
				// formula.g:190:42: CURR_BRL
				{
				DebugLocation(190, 42);
				mCURR_BRL(); 

				}
				break;
			case 13:
				DebugEnterAlt(13);
				// formula.g:190:51: CURR_KHR
				{
				DebugLocation(190, 51);
				mCURR_KHR(); 

				}
				break;
			case 14:
				DebugEnterAlt(14);
				// formula.g:190:60: CURR_CRC
				{
				DebugLocation(190, 60);
				mCURR_CRC(); 

				}
				break;
			case 15:
				DebugEnterAlt(15);
				// formula.g:191:6: CURR_HRK
				{
				DebugLocation(191, 6);
				mCURR_HRK(); 

				}
				break;
			case 16:
				DebugEnterAlt(16);
				// formula.g:191:15: CURR_CUP
				{
				DebugLocation(191, 15);
				mCURR_CUP(); 

				}
				break;
			case 17:
				DebugEnterAlt(17);
				// formula.g:191:24: CURR_CZK
				{
				DebugLocation(191, 24);
				mCURR_CZK(); 

				}
				break;
			case 18:
				DebugEnterAlt(18);
				// formula.g:191:33: CURR_DKK
				{
				DebugLocation(191, 33);
				mCURR_DKK(); 

				}
				break;
			case 19:
				DebugEnterAlt(19);
				// formula.g:191:42: CURR_DOP
				{
				DebugLocation(191, 42);
				mCURR_DOP(); 

				}
				break;
			case 20:
				DebugEnterAlt(20);
				// formula.g:191:51: CURR_GBP
				{
				DebugLocation(191, 51);
				mCURR_GBP(); 

				}
				break;
			case 21:
				DebugEnterAlt(21);
				// formula.g:191:60: CURR_EUR
				{
				DebugLocation(191, 60);
				mCURR_EUR(); 

				}
				break;
			case 22:
				DebugEnterAlt(22);
				// formula.g:191:69: CURR_GHS
				{
				DebugLocation(191, 69);
				mCURR_GHS(); 

				}
				break;
			case 23:
				DebugEnterAlt(23);
				// formula.g:192:6: CURR_GTQ
				{
				DebugLocation(192, 6);
				mCURR_GTQ(); 

				}
				break;
			case 24:
				DebugEnterAlt(24);
				// formula.g:192:15: CURR_HNL
				{
				DebugLocation(192, 15);
				mCURR_HNL(); 

				}
				break;
			case 25:
				DebugEnterAlt(25);
				// formula.g:192:24: CURR_HUF
				{
				DebugLocation(192, 24);
				mCURR_HUF(); 

				}
				break;
			case 26:
				DebugEnterAlt(26);
				// formula.g:192:33: CURR_IDR
				{
				DebugLocation(192, 33);
				mCURR_IDR(); 

				}
				break;
			case 27:
				DebugEnterAlt(27);
				// formula.g:192:42: CURR_IRR
				{
				DebugLocation(192, 42);
				mCURR_IRR(); 

				}
				break;
			case 28:
				DebugEnterAlt(28);
				// formula.g:192:51: CURR_ILS
				{
				DebugLocation(192, 51);
				mCURR_ILS(); 

				}
				break;
			case 29:
				DebugEnterAlt(29);
				// formula.g:192:60: CURR_JMD
				{
				DebugLocation(192, 60);
				mCURR_JMD(); 

				}
				break;
			case 30:
				DebugEnterAlt(30);
				// formula.g:192:69: CURR_JPY
				{
				DebugLocation(192, 69);
				mCURR_JPY(); 

				}
				break;
			case 31:
				DebugEnterAlt(31);
				// formula.g:193:6: CURR_LAK
				{
				DebugLocation(193, 6);
				mCURR_LAK(); 

				}
				break;
			case 32:
				DebugEnterAlt(32);
				// formula.g:193:15: CURR_MKD
				{
				DebugLocation(193, 15);
				mCURR_MKD(); 

				}
				break;
			case 33:
				DebugEnterAlt(33);
				// formula.g:193:24: CURR_MYR
				{
				DebugLocation(193, 24);
				mCURR_MYR(); 

				}
				break;
			case 34:
				DebugEnterAlt(34);
				// formula.g:193:33: CURR_MNT
				{
				DebugLocation(193, 33);
				mCURR_MNT(); 

				}
				break;
			case 35:
				DebugEnterAlt(35);
				// formula.g:193:42: CURR_MZN
				{
				DebugLocation(193, 42);
				mCURR_MZN(); 

				}
				break;
			case 36:
				DebugEnterAlt(36);
				// formula.g:193:51: CURR_NIO
				{
				DebugLocation(193, 51);
				mCURR_NIO(); 

				}
				break;
			case 37:
				DebugEnterAlt(37);
				// formula.g:193:60: CURR_NGN
				{
				DebugLocation(193, 60);
				mCURR_NGN(); 

				}
				break;
			case 38:
				DebugEnterAlt(38);
				// formula.g:193:69: CURR_PAB
				{
				DebugLocation(193, 69);
				mCURR_PAB(); 

				}
				break;
			case 39:
				DebugEnterAlt(39);
				// formula.g:194:6: CURR_PYG
				{
				DebugLocation(194, 6);
				mCURR_PYG(); 

				}
				break;
			case 40:
				DebugEnterAlt(40);
				// formula.g:194:15: CURR_PEN
				{
				DebugLocation(194, 15);
				mCURR_PEN(); 

				}
				break;
			case 41:
				DebugEnterAlt(41);
				// formula.g:194:24: CURR_PLN
				{
				DebugLocation(194, 24);
				mCURR_PLN(); 

				}
				break;
			case 42:
				DebugEnterAlt(42);
				// formula.g:194:33: CURR_RON
				{
				DebugLocation(194, 33);
				mCURR_RON(); 

				}
				break;
			case 43:
				DebugEnterAlt(43);
				// formula.g:194:42: CURR_RUB
				{
				DebugLocation(194, 42);
				mCURR_RUB(); 

				}
				break;
			case 44:
				DebugEnterAlt(44);
				// formula.g:194:51: CURR_RSD
				{
				DebugLocation(194, 51);
				mCURR_RSD(); 

				}
				break;
			case 45:
				DebugEnterAlt(45);
				// formula.g:194:60: CURR_SOS
				{
				DebugLocation(194, 60);
				mCURR_SOS(); 

				}
				break;
			case 46:
				DebugEnterAlt(46);
				// formula.g:194:69: CURR_ZAR
				{
				DebugLocation(194, 69);
				mCURR_ZAR(); 

				}
				break;
			case 47:
				DebugEnterAlt(47);
				// formula.g:195:6: CURR_CHF
				{
				DebugLocation(195, 6);
				mCURR_CHF(); 

				}
				break;
			case 48:
				DebugEnterAlt(48);
				// formula.g:195:15: CURR_TWD
				{
				DebugLocation(195, 15);
				mCURR_TWD(); 

				}
				break;
			case 49:
				DebugEnterAlt(49);
				// formula.g:195:24: CURR_THB
				{
				DebugLocation(195, 24);
				mCURR_THB(); 

				}
				break;
			case 50:
				DebugEnterAlt(50);
				// formula.g:195:33: CURR_TTD
				{
				DebugLocation(195, 33);
				mCURR_TTD(); 

				}
				break;
			case 51:
				DebugEnterAlt(51);
				// formula.g:195:42: CURR_UAH
				{
				DebugLocation(195, 42);
				mCURR_UAH(); 

				}
				break;
			case 52:
				DebugEnterAlt(52);
				// formula.g:195:51: CURR_UYU
				{
				DebugLocation(195, 51);
				mCURR_UYU(); 

				}
				break;
			case 53:
				DebugEnterAlt(53);
				// formula.g:195:60: CURR_VEF
				{
				DebugLocation(195, 60);
				mCURR_VEF(); 

				}
				break;
			case 54:
				DebugEnterAlt(54);
				// formula.g:195:69: CURR_VND
				{
				DebugLocation(195, 69);
				mCURR_VND(); 

				}
				break;
			case 55:
				DebugEnterAlt(55);
				// formula.g:196:6: CURR_ZWD
				{
				DebugLocation(196, 6);
				mCURR_ZWD(); 

				}
				break;
			case 56:
				DebugEnterAlt(56);
				// formula.g:196:15: CURR_XBT
				{
				DebugLocation(196, 15);
				mCURR_XBT(); 

				}
				break;

			}
			} finally { DebugExitSubRule(24); }


			}

		}
		finally
		{
			TraceOut("CURR_SYM", 94);
			LeaveRule("CURR_SYM", 94);
			LeaveRule_CURR_SYM();
		}
	}
	// $ANTLR end "CURR_SYM"

	partial void EnterRule_CURR_ALL();
	partial void LeaveRule_CURR_ALL();

	// $ANTLR start "CURR_ALL"
	[GrammarRule("CURR_ALL")]
	private void mCURR_ALL()
	{
		EnterRule_CURR_ALL();
		EnterRule("CURR_ALL", 95);
		TraceIn("CURR_ALL", 95);
		try
		{
			// formula.g:198:18: ( 'Lek' )
			DebugEnterAlt(1);
			// formula.g:198:20: 'Lek'
			{
			DebugLocation(198, 20);
			Match("Lek"); 


			}

		}
		finally
		{
			TraceOut("CURR_ALL", 95);
			LeaveRule("CURR_ALL", 95);
			LeaveRule_CURR_ALL();
		}
	}
	// $ANTLR end "CURR_ALL"

	partial void EnterRule_CURR_AFN();
	partial void LeaveRule_CURR_AFN();

	// $ANTLR start "CURR_AFN"
	[GrammarRule("CURR_AFN")]
	private void mCURR_AFN()
	{
		EnterRule_CURR_AFN();
		EnterRule("CURR_AFN", 96);
		TraceIn("CURR_AFN", 96);
		try
		{
			// formula.g:199:18: ( '\\u060B' )
			DebugEnterAlt(1);
			// formula.g:199:20: '\\u060B'
			{
			DebugLocation(199, 20);
			Match('\u060B'); 

			}

		}
		finally
		{
			TraceOut("CURR_AFN", 96);
			LeaveRule("CURR_AFN", 96);
			LeaveRule_CURR_AFN();
		}
	}
	// $ANTLR end "CURR_AFN"

	partial void EnterRule_CURR_USD();
	partial void LeaveRule_CURR_USD();

	// $ANTLR start "CURR_USD"
	[GrammarRule("CURR_USD")]
	private void mCURR_USD()
	{
		EnterRule_CURR_USD();
		EnterRule("CURR_USD", 97);
		TraceIn("CURR_USD", 97);
		try
		{
			// formula.g:200:18: ( '$' )
			DebugEnterAlt(1);
			// formula.g:200:20: '$'
			{
			DebugLocation(200, 20);
			Match('$'); 

			}

		}
		finally
		{
			TraceOut("CURR_USD", 97);
			LeaveRule("CURR_USD", 97);
			LeaveRule_CURR_USD();
		}
	}
	// $ANTLR end "CURR_USD"

	partial void EnterRule_CURR_AWG();
	partial void LeaveRule_CURR_AWG();

	// $ANTLR start "CURR_AWG"
	[GrammarRule("CURR_AWG")]
	private void mCURR_AWG()
	{
		EnterRule_CURR_AWG();
		EnterRule("CURR_AWG", 98);
		TraceIn("CURR_AWG", 98);
		try
		{
			// formula.g:212:18: ( '\\u0192' )
			DebugEnterAlt(1);
			// formula.g:212:20: '\\u0192'
			{
			DebugLocation(212, 20);
			Match('\u0192'); 

			}

		}
		finally
		{
			TraceOut("CURR_AWG", 98);
			LeaveRule("CURR_AWG", 98);
			LeaveRule_CURR_AWG();
		}
	}
	// $ANTLR end "CURR_AWG"

	partial void EnterRule_CURR_AZN();
	partial void LeaveRule_CURR_AZN();

	// $ANTLR start "CURR_AZN"
	[GrammarRule("CURR_AZN")]
	private void mCURR_AZN()
	{
		EnterRule_CURR_AZN();
		EnterRule("CURR_AZN", 99);
		TraceIn("CURR_AZN", 99);
		try
		{
			// formula.g:213:18: ( '\\u043c\\u0430\\u043d' )
			DebugEnterAlt(1);
			// formula.g:213:20: '\\u043c\\u0430\\u043d'
			{
			DebugLocation(213, 20);
			Match("\u043c\u0430\u043d"); 


			}

		}
		finally
		{
			TraceOut("CURR_AZN", 99);
			LeaveRule("CURR_AZN", 99);
			LeaveRule_CURR_AZN();
		}
	}
	// $ANTLR end "CURR_AZN"

	partial void EnterRule_CURR_BYR();
	partial void LeaveRule_CURR_BYR();

	// $ANTLR start "CURR_BYR"
	[GrammarRule("CURR_BYR")]
	private void mCURR_BYR()
	{
		EnterRule_CURR_BYR();
		EnterRule("CURR_BYR", 100);
		TraceIn("CURR_BYR", 100);
		try
		{
			// formula.g:214:18: ( 'p.' )
			DebugEnterAlt(1);
			// formula.g:214:20: 'p.'
			{
			DebugLocation(214, 20);
			Match("p."); 


			}

		}
		finally
		{
			TraceOut("CURR_BYR", 100);
			LeaveRule("CURR_BYR", 100);
			LeaveRule_CURR_BYR();
		}
	}
	// $ANTLR end "CURR_BYR"

	partial void EnterRule_CURR_BZD();
	partial void LeaveRule_CURR_BZD();

	// $ANTLR start "CURR_BZD"
	[GrammarRule("CURR_BZD")]
	private void mCURR_BZD()
	{
		EnterRule_CURR_BZD();
		EnterRule("CURR_BZD", 101);
		TraceIn("CURR_BZD", 101);
		try
		{
			// formula.g:215:18: ( 'BZ$' )
			DebugEnterAlt(1);
			// formula.g:215:20: 'BZ$'
			{
			DebugLocation(215, 20);
			Match("BZ$"); 


			}

		}
		finally
		{
			TraceOut("CURR_BZD", 101);
			LeaveRule("CURR_BZD", 101);
			LeaveRule_CURR_BZD();
		}
	}
	// $ANTLR end "CURR_BZD"

	partial void EnterRule_CURR_BOB();
	partial void LeaveRule_CURR_BOB();

	// $ANTLR start "CURR_BOB"
	[GrammarRule("CURR_BOB")]
	private void mCURR_BOB()
	{
		EnterRule_CURR_BOB();
		EnterRule("CURR_BOB", 102);
		TraceIn("CURR_BOB", 102);
		try
		{
			// formula.g:216:18: ( '$b' )
			DebugEnterAlt(1);
			// formula.g:216:20: '$b'
			{
			DebugLocation(216, 20);
			Match("$b"); 


			}

		}
		finally
		{
			TraceOut("CURR_BOB", 102);
			LeaveRule("CURR_BOB", 102);
			LeaveRule_CURR_BOB();
		}
	}
	// $ANTLR end "CURR_BOB"

	partial void EnterRule_CURR_BAM();
	partial void LeaveRule_CURR_BAM();

	// $ANTLR start "CURR_BAM"
	[GrammarRule("CURR_BAM")]
	private void mCURR_BAM()
	{
		EnterRule_CURR_BAM();
		EnterRule("CURR_BAM", 103);
		TraceIn("CURR_BAM", 103);
		try
		{
			// formula.g:217:18: ( 'KM' )
			DebugEnterAlt(1);
			// formula.g:217:20: 'KM'
			{
			DebugLocation(217, 20);
			Match("KM"); 


			}

		}
		finally
		{
			TraceOut("CURR_BAM", 103);
			LeaveRule("CURR_BAM", 103);
			LeaveRule_CURR_BAM();
		}
	}
	// $ANTLR end "CURR_BAM"

	partial void EnterRule_CURR_BWP();
	partial void LeaveRule_CURR_BWP();

	// $ANTLR start "CURR_BWP"
	[GrammarRule("CURR_BWP")]
	private void mCURR_BWP()
	{
		EnterRule_CURR_BWP();
		EnterRule("CURR_BWP", 104);
		TraceIn("CURR_BWP", 104);
		try
		{
			// formula.g:218:18: ( 'P' )
			DebugEnterAlt(1);
			// formula.g:218:20: 'P'
			{
			DebugLocation(218, 20);
			Match('P'); 

			}

		}
		finally
		{
			TraceOut("CURR_BWP", 104);
			LeaveRule("CURR_BWP", 104);
			LeaveRule_CURR_BWP();
		}
	}
	// $ANTLR end "CURR_BWP"

	partial void EnterRule_CURR_BGN();
	partial void LeaveRule_CURR_BGN();

	// $ANTLR start "CURR_BGN"
	[GrammarRule("CURR_BGN")]
	private void mCURR_BGN()
	{
		EnterRule_CURR_BGN();
		EnterRule("CURR_BGN", 105);
		TraceIn("CURR_BGN", 105);
		try
		{
			// formula.g:219:18: ( '\\u043b\\u0432' )
			DebugEnterAlt(1);
			// formula.g:219:20: '\\u043b\\u0432'
			{
			DebugLocation(219, 20);
			Match("\u043b\u0432"); 


			}

		}
		finally
		{
			TraceOut("CURR_BGN", 105);
			LeaveRule("CURR_BGN", 105);
			LeaveRule_CURR_BGN();
		}
	}
	// $ANTLR end "CURR_BGN"

	partial void EnterRule_CURR_BRL();
	partial void LeaveRule_CURR_BRL();

	// $ANTLR start "CURR_BRL"
	[GrammarRule("CURR_BRL")]
	private void mCURR_BRL()
	{
		EnterRule_CURR_BRL();
		EnterRule("CURR_BRL", 106);
		TraceIn("CURR_BRL", 106);
		try
		{
			// formula.g:221:18: ( 'R$' )
			DebugEnterAlt(1);
			// formula.g:221:20: 'R$'
			{
			DebugLocation(221, 20);
			Match("R$"); 


			}

		}
		finally
		{
			TraceOut("CURR_BRL", 106);
			LeaveRule("CURR_BRL", 106);
			LeaveRule_CURR_BRL();
		}
	}
	// $ANTLR end "CURR_BRL"

	partial void EnterRule_CURR_KHR();
	partial void LeaveRule_CURR_KHR();

	// $ANTLR start "CURR_KHR"
	[GrammarRule("CURR_KHR")]
	private void mCURR_KHR()
	{
		EnterRule_CURR_KHR();
		EnterRule("CURR_KHR", 107);
		TraceIn("CURR_KHR", 107);
		try
		{
			// formula.g:222:18: ( '\\u17db' )
			DebugEnterAlt(1);
			// formula.g:222:20: '\\u17db'
			{
			DebugLocation(222, 20);
			Match('\u17DB'); 

			}

		}
		finally
		{
			TraceOut("CURR_KHR", 107);
			LeaveRule("CURR_KHR", 107);
			LeaveRule_CURR_KHR();
		}
	}
	// $ANTLR end "CURR_KHR"

	partial void EnterRule_CURR_JPY();
	partial void LeaveRule_CURR_JPY();

	// $ANTLR start "CURR_JPY"
	[GrammarRule("CURR_JPY")]
	private void mCURR_JPY()
	{
		EnterRule_CURR_JPY();
		EnterRule("CURR_JPY", 108);
		TraceIn("CURR_JPY", 108);
		try
		{
			// formula.g:223:18: ( '¥' )
			DebugEnterAlt(1);
			// formula.g:223:20: '¥'
			{
			DebugLocation(223, 20);
			Match('\u00A5'); 

			}

		}
		finally
		{
			TraceOut("CURR_JPY", 108);
			LeaveRule("CURR_JPY", 108);
			LeaveRule_CURR_JPY();
		}
	}
	// $ANTLR end "CURR_JPY"

	partial void EnterRule_CURR_CRC();
	partial void LeaveRule_CURR_CRC();

	// $ANTLR start "CURR_CRC"
	[GrammarRule("CURR_CRC")]
	private void mCURR_CRC()
	{
		EnterRule_CURR_CRC();
		EnterRule("CURR_CRC", 109);
		TraceIn("CURR_CRC", 109);
		try
		{
			// formula.g:224:18: ( '\\u20a1' )
			DebugEnterAlt(1);
			// formula.g:224:20: '\\u20a1'
			{
			DebugLocation(224, 20);
			Match('\u20A1'); 

			}

		}
		finally
		{
			TraceOut("CURR_CRC", 109);
			LeaveRule("CURR_CRC", 109);
			LeaveRule_CURR_CRC();
		}
	}
	// $ANTLR end "CURR_CRC"

	partial void EnterRule_CURR_HRK();
	partial void LeaveRule_CURR_HRK();

	// $ANTLR start "CURR_HRK"
	[GrammarRule("CURR_HRK")]
	private void mCURR_HRK()
	{
		EnterRule_CURR_HRK();
		EnterRule("CURR_HRK", 110);
		TraceIn("CURR_HRK", 110);
		try
		{
			// formula.g:225:18: ( 'kn' )
			DebugEnterAlt(1);
			// formula.g:225:20: 'kn'
			{
			DebugLocation(225, 20);
			Match("kn"); 


			}

		}
		finally
		{
			TraceOut("CURR_HRK", 110);
			LeaveRule("CURR_HRK", 110);
			LeaveRule_CURR_HRK();
		}
	}
	// $ANTLR end "CURR_HRK"

	partial void EnterRule_CURR_CUP();
	partial void LeaveRule_CURR_CUP();

	// $ANTLR start "CURR_CUP"
	[GrammarRule("CURR_CUP")]
	private void mCURR_CUP()
	{
		EnterRule_CURR_CUP();
		EnterRule("CURR_CUP", 111);
		TraceIn("CURR_CUP", 111);
		try
		{
			// formula.g:226:18: ( '\\u20b1' )
			DebugEnterAlt(1);
			// formula.g:226:20: '\\u20b1'
			{
			DebugLocation(226, 20);
			Match('\u20B1'); 

			}

		}
		finally
		{
			TraceOut("CURR_CUP", 111);
			LeaveRule("CURR_CUP", 111);
			LeaveRule_CURR_CUP();
		}
	}
	// $ANTLR end "CURR_CUP"

	partial void EnterRule_CURR_CZK();
	partial void LeaveRule_CURR_CZK();

	// $ANTLR start "CURR_CZK"
	[GrammarRule("CURR_CZK")]
	private void mCURR_CZK()
	{
		EnterRule_CURR_CZK();
		EnterRule("CURR_CZK", 112);
		TraceIn("CURR_CZK", 112);
		try
		{
			// formula.g:227:18: ( 'K\\u010d' )
			DebugEnterAlt(1);
			// formula.g:227:20: 'K\\u010d'
			{
			DebugLocation(227, 20);
			Match("K\u010d"); 


			}

		}
		finally
		{
			TraceOut("CURR_CZK", 112);
			LeaveRule("CURR_CZK", 112);
			LeaveRule_CURR_CZK();
		}
	}
	// $ANTLR end "CURR_CZK"

	partial void EnterRule_CURR_DKK();
	partial void LeaveRule_CURR_DKK();

	// $ANTLR start "CURR_DKK"
	[GrammarRule("CURR_DKK")]
	private void mCURR_DKK()
	{
		EnterRule_CURR_DKK();
		EnterRule("CURR_DKK", 113);
		TraceIn("CURR_DKK", 113);
		try
		{
			// formula.g:228:18: ( 'kr' )
			DebugEnterAlt(1);
			// formula.g:228:20: 'kr'
			{
			DebugLocation(228, 20);
			Match("kr"); 


			}

		}
		finally
		{
			TraceOut("CURR_DKK", 113);
			LeaveRule("CURR_DKK", 113);
			LeaveRule_CURR_DKK();
		}
	}
	// $ANTLR end "CURR_DKK"

	partial void EnterRule_CURR_DOP();
	partial void LeaveRule_CURR_DOP();

	// $ANTLR start "CURR_DOP"
	[GrammarRule("CURR_DOP")]
	private void mCURR_DOP()
	{
		EnterRule_CURR_DOP();
		EnterRule("CURR_DOP", 114);
		TraceIn("CURR_DOP", 114);
		try
		{
			// formula.g:230:18: ( 'RD$' )
			DebugEnterAlt(1);
			// formula.g:230:20: 'RD$'
			{
			DebugLocation(230, 20);
			Match("RD$"); 


			}

		}
		finally
		{
			TraceOut("CURR_DOP", 114);
			LeaveRule("CURR_DOP", 114);
			LeaveRule_CURR_DOP();
		}
	}
	// $ANTLR end "CURR_DOP"

	partial void EnterRule_CURR_GBP();
	partial void LeaveRule_CURR_GBP();

	// $ANTLR start "CURR_GBP"
	[GrammarRule("CURR_GBP")]
	private void mCURR_GBP()
	{
		EnterRule_CURR_GBP();
		EnterRule("CURR_GBP", 115);
		TraceIn("CURR_GBP", 115);
		try
		{
			// formula.g:231:18: ( '£' )
			DebugEnterAlt(1);
			// formula.g:231:20: '£'
			{
			DebugLocation(231, 20);
			Match('\u00A3'); 

			}

		}
		finally
		{
			TraceOut("CURR_GBP", 115);
			LeaveRule("CURR_GBP", 115);
			LeaveRule_CURR_GBP();
		}
	}
	// $ANTLR end "CURR_GBP"

	partial void EnterRule_CURR_EUR();
	partial void LeaveRule_CURR_EUR();

	// $ANTLR start "CURR_EUR"
	[GrammarRule("CURR_EUR")]
	private void mCURR_EUR()
	{
		EnterRule_CURR_EUR();
		EnterRule("CURR_EUR", 116);
		TraceIn("CURR_EUR", 116);
		try
		{
			// formula.g:237:18: ( '€' )
			DebugEnterAlt(1);
			// formula.g:237:20: '€'
			{
			DebugLocation(237, 20);
			Match('\u20AC'); 

			}

		}
		finally
		{
			TraceOut("CURR_EUR", 116);
			LeaveRule("CURR_EUR", 116);
			LeaveRule_CURR_EUR();
		}
	}
	// $ANTLR end "CURR_EUR"

	partial void EnterRule_CURR_GHS();
	partial void LeaveRule_CURR_GHS();

	// $ANTLR start "CURR_GHS"
	[GrammarRule("CURR_GHS")]
	private void mCURR_GHS()
	{
		EnterRule_CURR_GHS();
		EnterRule("CURR_GHS", 117);
		TraceIn("CURR_GHS", 117);
		try
		{
			// formula.g:238:18: ( '\\u00a2' )
			DebugEnterAlt(1);
			// formula.g:238:20: '\\u00a2'
			{
			DebugLocation(238, 20);
			Match('\u00A2'); 

			}

		}
		finally
		{
			TraceOut("CURR_GHS", 117);
			LeaveRule("CURR_GHS", 117);
			LeaveRule_CURR_GHS();
		}
	}
	// $ANTLR end "CURR_GHS"

	partial void EnterRule_CURR_GTQ();
	partial void LeaveRule_CURR_GTQ();

	// $ANTLR start "CURR_GTQ"
	[GrammarRule("CURR_GTQ")]
	private void mCURR_GTQ()
	{
		EnterRule_CURR_GTQ();
		EnterRule("CURR_GTQ", 118);
		TraceIn("CURR_GTQ", 118);
		try
		{
			// formula.g:239:18: ( 'Q' )
			DebugEnterAlt(1);
			// formula.g:239:20: 'Q'
			{
			DebugLocation(239, 20);
			Match('Q'); 

			}

		}
		finally
		{
			TraceOut("CURR_GTQ", 118);
			LeaveRule("CURR_GTQ", 118);
			LeaveRule_CURR_GTQ();
		}
	}
	// $ANTLR end "CURR_GTQ"

	partial void EnterRule_CURR_HNL();
	partial void LeaveRule_CURR_HNL();

	// $ANTLR start "CURR_HNL"
	[GrammarRule("CURR_HNL")]
	private void mCURR_HNL()
	{
		EnterRule_CURR_HNL();
		EnterRule("CURR_HNL", 119);
		TraceIn("CURR_HNL", 119);
		try
		{
			// formula.g:240:18: ( 'L' )
			DebugEnterAlt(1);
			// formula.g:240:20: 'L'
			{
			DebugLocation(240, 20);
			Match('L'); 

			}

		}
		finally
		{
			TraceOut("CURR_HNL", 119);
			LeaveRule("CURR_HNL", 119);
			LeaveRule_CURR_HNL();
		}
	}
	// $ANTLR end "CURR_HNL"

	partial void EnterRule_CURR_HUF();
	partial void LeaveRule_CURR_HUF();

	// $ANTLR start "CURR_HUF"
	[GrammarRule("CURR_HUF")]
	private void mCURR_HUF()
	{
		EnterRule_CURR_HUF();
		EnterRule("CURR_HUF", 120);
		TraceIn("CURR_HUF", 120);
		try
		{
			// formula.g:241:18: ( 'Ft' )
			DebugEnterAlt(1);
			// formula.g:241:20: 'Ft'
			{
			DebugLocation(241, 20);
			Match("Ft"); 


			}

		}
		finally
		{
			TraceOut("CURR_HUF", 120);
			LeaveRule("CURR_HUF", 120);
			LeaveRule_CURR_HUF();
		}
	}
	// $ANTLR end "CURR_HUF"

	partial void EnterRule_CURR_IDR();
	partial void LeaveRule_CURR_IDR();

	// $ANTLR start "CURR_IDR"
	[GrammarRule("CURR_IDR")]
	private void mCURR_IDR()
	{
		EnterRule_CURR_IDR();
		EnterRule("CURR_IDR", 121);
		TraceIn("CURR_IDR", 121);
		try
		{
			// formula.g:242:18: ( 'Rp' )
			DebugEnterAlt(1);
			// formula.g:242:20: 'Rp'
			{
			DebugLocation(242, 20);
			Match("Rp"); 


			}

		}
		finally
		{
			TraceOut("CURR_IDR", 121);
			LeaveRule("CURR_IDR", 121);
			LeaveRule_CURR_IDR();
		}
	}
	// $ANTLR end "CURR_IDR"

	partial void EnterRule_CURR_IRR();
	partial void LeaveRule_CURR_IRR();

	// $ANTLR start "CURR_IRR"
	[GrammarRule("CURR_IRR")]
	private void mCURR_IRR()
	{
		EnterRule_CURR_IRR();
		EnterRule("CURR_IRR", 122);
		TraceIn("CURR_IRR", 122);
		try
		{
			// formula.g:243:18: ( '\\ufdfc' )
			DebugEnterAlt(1);
			// formula.g:243:20: '\\ufdfc'
			{
			DebugLocation(243, 20);
			Match('\uFDFC'); 

			}

		}
		finally
		{
			TraceOut("CURR_IRR", 122);
			LeaveRule("CURR_IRR", 122);
			LeaveRule_CURR_IRR();
		}
	}
	// $ANTLR end "CURR_IRR"

	partial void EnterRule_CURR_ILS();
	partial void LeaveRule_CURR_ILS();

	// $ANTLR start "CURR_ILS"
	[GrammarRule("CURR_ILS")]
	private void mCURR_ILS()
	{
		EnterRule_CURR_ILS();
		EnterRule("CURR_ILS", 123);
		TraceIn("CURR_ILS", 123);
		try
		{
			// formula.g:245:18: ( '\\u20aa' )
			DebugEnterAlt(1);
			// formula.g:245:20: '\\u20aa'
			{
			DebugLocation(245, 20);
			Match('\u20AA'); 

			}

		}
		finally
		{
			TraceOut("CURR_ILS", 123);
			LeaveRule("CURR_ILS", 123);
			LeaveRule_CURR_ILS();
		}
	}
	// $ANTLR end "CURR_ILS"

	partial void EnterRule_CURR_JMD();
	partial void LeaveRule_CURR_JMD();

	// $ANTLR start "CURR_JMD"
	[GrammarRule("CURR_JMD")]
	private void mCURR_JMD()
	{
		EnterRule_CURR_JMD();
		EnterRule("CURR_JMD", 124);
		TraceIn("CURR_JMD", 124);
		try
		{
			// formula.g:246:18: ( 'J$' )
			DebugEnterAlt(1);
			// formula.g:246:20: 'J$'
			{
			DebugLocation(246, 20);
			Match("J$"); 


			}

		}
		finally
		{
			TraceOut("CURR_JMD", 124);
			LeaveRule("CURR_JMD", 124);
			LeaveRule_CURR_JMD();
		}
	}
	// $ANTLR end "CURR_JMD"

	partial void EnterRule_CURR_KPW();
	partial void LeaveRule_CURR_KPW();

	// $ANTLR start "CURR_KPW"
	[GrammarRule("CURR_KPW")]
	private void mCURR_KPW()
	{
		EnterRule_CURR_KPW();
		EnterRule("CURR_KPW", 125);
		TraceIn("CURR_KPW", 125);
		try
		{
			// formula.g:247:18: ( '\\u20a9' )
			DebugEnterAlt(1);
			// formula.g:247:20: '\\u20a9'
			{
			DebugLocation(247, 20);
			Match('\u20A9'); 

			}

		}
		finally
		{
			TraceOut("CURR_KPW", 125);
			LeaveRule("CURR_KPW", 125);
			LeaveRule_CURR_KPW();
		}
	}
	// $ANTLR end "CURR_KPW"

	partial void EnterRule_CURR_LAK();
	partial void LeaveRule_CURR_LAK();

	// $ANTLR start "CURR_LAK"
	[GrammarRule("CURR_LAK")]
	private void mCURR_LAK()
	{
		EnterRule_CURR_LAK();
		EnterRule("CURR_LAK", 126);
		TraceIn("CURR_LAK", 126);
		try
		{
			// formula.g:248:18: ( '\\u20ad' )
			DebugEnterAlt(1);
			// formula.g:248:20: '\\u20ad'
			{
			DebugLocation(248, 20);
			Match('\u20AD'); 

			}

		}
		finally
		{
			TraceOut("CURR_LAK", 126);
			LeaveRule("CURR_LAK", 126);
			LeaveRule_CURR_LAK();
		}
	}
	// $ANTLR end "CURR_LAK"

	partial void EnterRule_CURR_MKD();
	partial void LeaveRule_CURR_MKD();

	// $ANTLR start "CURR_MKD"
	[GrammarRule("CURR_MKD")]
	private void mCURR_MKD()
	{
		EnterRule_CURR_MKD();
		EnterRule("CURR_MKD", 127);
		TraceIn("CURR_MKD", 127);
		try
		{
			// formula.g:249:18: ( '\\u0434\\u0435\\u043d' )
			DebugEnterAlt(1);
			// formula.g:249:20: '\\u0434\\u0435\\u043d'
			{
			DebugLocation(249, 20);
			Match("\u0434\u0435\u043d"); 


			}

		}
		finally
		{
			TraceOut("CURR_MKD", 127);
			LeaveRule("CURR_MKD", 127);
			LeaveRule_CURR_MKD();
		}
	}
	// $ANTLR end "CURR_MKD"

	partial void EnterRule_CURR_MYR();
	partial void LeaveRule_CURR_MYR();

	// $ANTLR start "CURR_MYR"
	[GrammarRule("CURR_MYR")]
	private void mCURR_MYR()
	{
		EnterRule_CURR_MYR();
		EnterRule("CURR_MYR", 128);
		TraceIn("CURR_MYR", 128);
		try
		{
			// formula.g:250:18: ( 'RM' )
			DebugEnterAlt(1);
			// formula.g:250:20: 'RM'
			{
			DebugLocation(250, 20);
			Match("RM"); 


			}

		}
		finally
		{
			TraceOut("CURR_MYR", 128);
			LeaveRule("CURR_MYR", 128);
			LeaveRule_CURR_MYR();
		}
	}
	// $ANTLR end "CURR_MYR"

	partial void EnterRule_CURR_MUR();
	partial void LeaveRule_CURR_MUR();

	// $ANTLR start "CURR_MUR"
	[GrammarRule("CURR_MUR")]
	private void mCURR_MUR()
	{
		EnterRule_CURR_MUR();
		EnterRule("CURR_MUR", 129);
		TraceIn("CURR_MUR", 129);
		try
		{
			// formula.g:251:18: ( '\\u20a8' )
			DebugEnterAlt(1);
			// formula.g:251:20: '\\u20a8'
			{
			DebugLocation(251, 20);
			Match('\u20A8'); 

			}

		}
		finally
		{
			TraceOut("CURR_MUR", 129);
			LeaveRule("CURR_MUR", 129);
			LeaveRule_CURR_MUR();
		}
	}
	// $ANTLR end "CURR_MUR"

	partial void EnterRule_CURR_MNT();
	partial void LeaveRule_CURR_MNT();

	// $ANTLR start "CURR_MNT"
	[GrammarRule("CURR_MNT")]
	private void mCURR_MNT()
	{
		EnterRule_CURR_MNT();
		EnterRule("CURR_MNT", 130);
		TraceIn("CURR_MNT", 130);
		try
		{
			// formula.g:254:18: ( '\\u20ae' )
			DebugEnterAlt(1);
			// formula.g:254:20: '\\u20ae'
			{
			DebugLocation(254, 20);
			Match('\u20AE'); 

			}

		}
		finally
		{
			TraceOut("CURR_MNT", 130);
			LeaveRule("CURR_MNT", 130);
			LeaveRule_CURR_MNT();
		}
	}
	// $ANTLR end "CURR_MNT"

	partial void EnterRule_CURR_MZN();
	partial void LeaveRule_CURR_MZN();

	// $ANTLR start "CURR_MZN"
	[GrammarRule("CURR_MZN")]
	private void mCURR_MZN()
	{
		EnterRule_CURR_MZN();
		EnterRule("CURR_MZN", 131);
		TraceIn("CURR_MZN", 131);
		try
		{
			// formula.g:255:18: ( 'MT' )
			DebugEnterAlt(1);
			// formula.g:255:20: 'MT'
			{
			DebugLocation(255, 20);
			Match("MT"); 


			}

		}
		finally
		{
			TraceOut("CURR_MZN", 131);
			LeaveRule("CURR_MZN", 131);
			LeaveRule_CURR_MZN();
		}
	}
	// $ANTLR end "CURR_MZN"

	partial void EnterRule_CURR_NIO();
	partial void LeaveRule_CURR_NIO();

	// $ANTLR start "CURR_NIO"
	[GrammarRule("CURR_NIO")]
	private void mCURR_NIO()
	{
		EnterRule_CURR_NIO();
		EnterRule("CURR_NIO", 132);
		TraceIn("CURR_NIO", 132);
		try
		{
			// formula.g:256:18: ( 'C$' )
			DebugEnterAlt(1);
			// formula.g:256:20: 'C$'
			{
			DebugLocation(256, 20);
			Match("C$"); 


			}

		}
		finally
		{
			TraceOut("CURR_NIO", 132);
			LeaveRule("CURR_NIO", 132);
			LeaveRule_CURR_NIO();
		}
	}
	// $ANTLR end "CURR_NIO"

	partial void EnterRule_CURR_NGN();
	partial void LeaveRule_CURR_NGN();

	// $ANTLR start "CURR_NGN"
	[GrammarRule("CURR_NGN")]
	private void mCURR_NGN()
	{
		EnterRule_CURR_NGN();
		EnterRule("CURR_NGN", 133);
		TraceIn("CURR_NGN", 133);
		try
		{
			// formula.g:257:18: ( '\\u20a6' )
			DebugEnterAlt(1);
			// formula.g:257:20: '\\u20a6'
			{
			DebugLocation(257, 20);
			Match('\u20A6'); 

			}

		}
		finally
		{
			TraceOut("CURR_NGN", 133);
			LeaveRule("CURR_NGN", 133);
			LeaveRule_CURR_NGN();
		}
	}
	// $ANTLR end "CURR_NGN"

	partial void EnterRule_CURR_PAB();
	partial void LeaveRule_CURR_PAB();

	// $ANTLR start "CURR_PAB"
	[GrammarRule("CURR_PAB")]
	private void mCURR_PAB()
	{
		EnterRule_CURR_PAB();
		EnterRule("CURR_PAB", 134);
		TraceIn("CURR_PAB", 134);
		try
		{
			// formula.g:258:18: ( 'B\\/\\.' )
			DebugEnterAlt(1);
			// formula.g:258:20: 'B\\/\\.'
			{
			DebugLocation(258, 20);
			Match("B/."); 


			}

		}
		finally
		{
			TraceOut("CURR_PAB", 134);
			LeaveRule("CURR_PAB", 134);
			LeaveRule_CURR_PAB();
		}
	}
	// $ANTLR end "CURR_PAB"

	partial void EnterRule_CURR_PYG();
	partial void LeaveRule_CURR_PYG();

	// $ANTLR start "CURR_PYG"
	[GrammarRule("CURR_PYG")]
	private void mCURR_PYG()
	{
		EnterRule_CURR_PYG();
		EnterRule("CURR_PYG", 135);
		TraceIn("CURR_PYG", 135);
		try
		{
			// formula.g:259:18: ( 'Gs' )
			DebugEnterAlt(1);
			// formula.g:259:20: 'Gs'
			{
			DebugLocation(259, 20);
			Match("Gs"); 


			}

		}
		finally
		{
			TraceOut("CURR_PYG", 135);
			LeaveRule("CURR_PYG", 135);
			LeaveRule_CURR_PYG();
		}
	}
	// $ANTLR end "CURR_PYG"

	partial void EnterRule_CURR_PEN();
	partial void LeaveRule_CURR_PEN();

	// $ANTLR start "CURR_PEN"
	[GrammarRule("CURR_PEN")]
	private void mCURR_PEN()
	{
		EnterRule_CURR_PEN();
		EnterRule("CURR_PEN", 136);
		TraceIn("CURR_PEN", 136);
		try
		{
			// formula.g:260:18: ( 'S/.' )
			DebugEnterAlt(1);
			// formula.g:260:20: 'S/.'
			{
			DebugLocation(260, 20);
			Match("S/."); 


			}

		}
		finally
		{
			TraceOut("CURR_PEN", 136);
			LeaveRule("CURR_PEN", 136);
			LeaveRule_CURR_PEN();
		}
	}
	// $ANTLR end "CURR_PEN"

	partial void EnterRule_CURR_PLN();
	partial void LeaveRule_CURR_PLN();

	// $ANTLR start "CURR_PLN"
	[GrammarRule("CURR_PLN")]
	private void mCURR_PLN()
	{
		EnterRule_CURR_PLN();
		EnterRule("CURR_PLN", 137);
		TraceIn("CURR_PLN", 137);
		try
		{
			// formula.g:261:18: ( 'z\\u0142' )
			DebugEnterAlt(1);
			// formula.g:261:20: 'z\\u0142'
			{
			DebugLocation(261, 20);
			Match("z\u0142"); 


			}

		}
		finally
		{
			TraceOut("CURR_PLN", 137);
			LeaveRule("CURR_PLN", 137);
			LeaveRule_CURR_PLN();
		}
	}
	// $ANTLR end "CURR_PLN"

	partial void EnterRule_CURR_RON();
	partial void LeaveRule_CURR_RON();

	// $ANTLR start "CURR_RON"
	[GrammarRule("CURR_RON")]
	private void mCURR_RON()
	{
		EnterRule_CURR_RON();
		EnterRule("CURR_RON", 138);
		TraceIn("CURR_RON", 138);
		try
		{
			// formula.g:262:18: ( 'lei' )
			DebugEnterAlt(1);
			// formula.g:262:20: 'lei'
			{
			DebugLocation(262, 20);
			Match("lei"); 


			}

		}
		finally
		{
			TraceOut("CURR_RON", 138);
			LeaveRule("CURR_RON", 138);
			LeaveRule_CURR_RON();
		}
	}
	// $ANTLR end "CURR_RON"

	partial void EnterRule_CURR_RUB();
	partial void LeaveRule_CURR_RUB();

	// $ANTLR start "CURR_RUB"
	[GrammarRule("CURR_RUB")]
	private void mCURR_RUB()
	{
		EnterRule_CURR_RUB();
		EnterRule("CURR_RUB", 139);
		TraceIn("CURR_RUB", 139);
		try
		{
			// formula.g:263:18: ( '\\u0440\\u0443\\u0431' )
			DebugEnterAlt(1);
			// formula.g:263:20: '\\u0440\\u0443\\u0431'
			{
			DebugLocation(263, 20);
			Match("\u0440\u0443\u0431"); 


			}

		}
		finally
		{
			TraceOut("CURR_RUB", 139);
			LeaveRule("CURR_RUB", 139);
			LeaveRule_CURR_RUB();
		}
	}
	// $ANTLR end "CURR_RUB"

	partial void EnterRule_CURR_RSD();
	partial void LeaveRule_CURR_RSD();

	// $ANTLR start "CURR_RSD"
	[GrammarRule("CURR_RSD")]
	private void mCURR_RSD()
	{
		EnterRule_CURR_RSD();
		EnterRule("CURR_RSD", 140);
		TraceIn("CURR_RSD", 140);
		try
		{
			// formula.g:264:18: ( '\\u0414\\u0438\\u043d\\.' )
			DebugEnterAlt(1);
			// formula.g:264:20: '\\u0414\\u0438\\u043d\\.'
			{
			DebugLocation(264, 20);
			Match("\u0414\u0438\u043d."); 


			}

		}
		finally
		{
			TraceOut("CURR_RSD", 140);
			LeaveRule("CURR_RSD", 140);
			LeaveRule_CURR_RSD();
		}
	}
	// $ANTLR end "CURR_RSD"

	partial void EnterRule_CURR_SOS();
	partial void LeaveRule_CURR_SOS();

	// $ANTLR start "CURR_SOS"
	[GrammarRule("CURR_SOS")]
	private void mCURR_SOS()
	{
		EnterRule_CURR_SOS();
		EnterRule("CURR_SOS", 141);
		TraceIn("CURR_SOS", 141);
		try
		{
			// formula.g:265:18: ( 'S' )
			DebugEnterAlt(1);
			// formula.g:265:20: 'S'
			{
			DebugLocation(265, 20);
			Match('S'); 

			}

		}
		finally
		{
			TraceOut("CURR_SOS", 141);
			LeaveRule("CURR_SOS", 141);
			LeaveRule_CURR_SOS();
		}
	}
	// $ANTLR end "CURR_SOS"

	partial void EnterRule_CURR_ZAR();
	partial void LeaveRule_CURR_ZAR();

	// $ANTLR start "CURR_ZAR"
	[GrammarRule("CURR_ZAR")]
	private void mCURR_ZAR()
	{
		EnterRule_CURR_ZAR();
		EnterRule("CURR_ZAR", 142);
		TraceIn("CURR_ZAR", 142);
		try
		{
			// formula.g:266:18: ( 'R' )
			DebugEnterAlt(1);
			// formula.g:266:20: 'R'
			{
			DebugLocation(266, 20);
			Match('R'); 

			}

		}
		finally
		{
			TraceOut("CURR_ZAR", 142);
			LeaveRule("CURR_ZAR", 142);
			LeaveRule_CURR_ZAR();
		}
	}
	// $ANTLR end "CURR_ZAR"

	partial void EnterRule_CURR_CHF();
	partial void LeaveRule_CURR_CHF();

	// $ANTLR start "CURR_CHF"
	[GrammarRule("CURR_CHF")]
	private void mCURR_CHF()
	{
		EnterRule_CURR_CHF();
		EnterRule("CURR_CHF", 143);
		TraceIn("CURR_CHF", 143);
		try
		{
			// formula.g:267:18: ( 'CHF' )
			DebugEnterAlt(1);
			// formula.g:267:20: 'CHF'
			{
			DebugLocation(267, 20);
			Match("CHF"); 


			}

		}
		finally
		{
			TraceOut("CURR_CHF", 143);
			LeaveRule("CURR_CHF", 143);
			LeaveRule_CURR_CHF();
		}
	}
	// $ANTLR end "CURR_CHF"

	partial void EnterRule_CURR_TWD();
	partial void LeaveRule_CURR_TWD();

	// $ANTLR start "CURR_TWD"
	[GrammarRule("CURR_TWD")]
	private void mCURR_TWD()
	{
		EnterRule_CURR_TWD();
		EnterRule("CURR_TWD", 144);
		TraceIn("CURR_TWD", 144);
		try
		{
			// formula.g:268:18: ( 'NT$' )
			DebugEnterAlt(1);
			// formula.g:268:20: 'NT$'
			{
			DebugLocation(268, 20);
			Match("NT$"); 


			}

		}
		finally
		{
			TraceOut("CURR_TWD", 144);
			LeaveRule("CURR_TWD", 144);
			LeaveRule_CURR_TWD();
		}
	}
	// $ANTLR end "CURR_TWD"

	partial void EnterRule_CURR_THB();
	partial void LeaveRule_CURR_THB();

	// $ANTLR start "CURR_THB"
	[GrammarRule("CURR_THB")]
	private void mCURR_THB()
	{
		EnterRule_CURR_THB();
		EnterRule("CURR_THB", 145);
		TraceIn("CURR_THB", 145);
		try
		{
			// formula.g:269:18: ( '\\u0e3f' )
			DebugEnterAlt(1);
			// formula.g:269:20: '\\u0e3f'
			{
			DebugLocation(269, 20);
			Match('\u0E3F'); 

			}

		}
		finally
		{
			TraceOut("CURR_THB", 145);
			LeaveRule("CURR_THB", 145);
			LeaveRule_CURR_THB();
		}
	}
	// $ANTLR end "CURR_THB"

	partial void EnterRule_CURR_TTD();
	partial void LeaveRule_CURR_TTD();

	// $ANTLR start "CURR_TTD"
	[GrammarRule("CURR_TTD")]
	private void mCURR_TTD()
	{
		EnterRule_CURR_TTD();
		EnterRule("CURR_TTD", 146);
		TraceIn("CURR_TTD", 146);
		try
		{
			// formula.g:270:18: ( 'TT$' )
			DebugEnterAlt(1);
			// formula.g:270:20: 'TT$'
			{
			DebugLocation(270, 20);
			Match("TT$"); 


			}

		}
		finally
		{
			TraceOut("CURR_TTD", 146);
			LeaveRule("CURR_TTD", 146);
			LeaveRule_CURR_TTD();
		}
	}
	// $ANTLR end "CURR_TTD"

	partial void EnterRule_CURR_UAH();
	partial void LeaveRule_CURR_UAH();

	// $ANTLR start "CURR_UAH"
	[GrammarRule("CURR_UAH")]
	private void mCURR_UAH()
	{
		EnterRule_CURR_UAH();
		EnterRule("CURR_UAH", 147);
		TraceIn("CURR_UAH", 147);
		try
		{
			// formula.g:271:18: ( '\\u20b4' )
			DebugEnterAlt(1);
			// formula.g:271:20: '\\u20b4'
			{
			DebugLocation(271, 20);
			Match('\u20B4'); 

			}

		}
		finally
		{
			TraceOut("CURR_UAH", 147);
			LeaveRule("CURR_UAH", 147);
			LeaveRule_CURR_UAH();
		}
	}
	// $ANTLR end "CURR_UAH"

	partial void EnterRule_CURR_UYU();
	partial void LeaveRule_CURR_UYU();

	// $ANTLR start "CURR_UYU"
	[GrammarRule("CURR_UYU")]
	private void mCURR_UYU()
	{
		EnterRule_CURR_UYU();
		EnterRule("CURR_UYU", 148);
		TraceIn("CURR_UYU", 148);
		try
		{
			// formula.g:272:18: ( '$U' )
			DebugEnterAlt(1);
			// formula.g:272:20: '$U'
			{
			DebugLocation(272, 20);
			Match("$U"); 


			}

		}
		finally
		{
			TraceOut("CURR_UYU", 148);
			LeaveRule("CURR_UYU", 148);
			LeaveRule_CURR_UYU();
		}
	}
	// $ANTLR end "CURR_UYU"

	partial void EnterRule_CURR_VEF();
	partial void LeaveRule_CURR_VEF();

	// $ANTLR start "CURR_VEF"
	[GrammarRule("CURR_VEF")]
	private void mCURR_VEF()
	{
		EnterRule_CURR_VEF();
		EnterRule("CURR_VEF", 149);
		TraceIn("CURR_VEF", 149);
		try
		{
			// formula.g:273:18: ( 'Bs' )
			DebugEnterAlt(1);
			// formula.g:273:20: 'Bs'
			{
			DebugLocation(273, 20);
			Match("Bs"); 


			}

		}
		finally
		{
			TraceOut("CURR_VEF", 149);
			LeaveRule("CURR_VEF", 149);
			LeaveRule_CURR_VEF();
		}
	}
	// $ANTLR end "CURR_VEF"

	partial void EnterRule_CURR_VND();
	partial void LeaveRule_CURR_VND();

	// $ANTLR start "CURR_VND"
	[GrammarRule("CURR_VND")]
	private void mCURR_VND()
	{
		EnterRule_CURR_VND();
		EnterRule("CURR_VND", 150);
		TraceIn("CURR_VND", 150);
		try
		{
			// formula.g:274:18: ( '\\u20ab' )
			DebugEnterAlt(1);
			// formula.g:274:20: '\\u20ab'
			{
			DebugLocation(274, 20);
			Match('\u20AB'); 

			}

		}
		finally
		{
			TraceOut("CURR_VND", 150);
			LeaveRule("CURR_VND", 150);
			LeaveRule_CURR_VND();
		}
	}
	// $ANTLR end "CURR_VND"

	partial void EnterRule_CURR_ZWD();
	partial void LeaveRule_CURR_ZWD();

	// $ANTLR start "CURR_ZWD"
	[GrammarRule("CURR_ZWD")]
	private void mCURR_ZWD()
	{
		EnterRule_CURR_ZWD();
		EnterRule("CURR_ZWD", 151);
		TraceIn("CURR_ZWD", 151);
		try
		{
			// formula.g:275:18: ( 'Z$' )
			DebugEnterAlt(1);
			// formula.g:275:20: 'Z$'
			{
			DebugLocation(275, 20);
			Match("Z$"); 


			}

		}
		finally
		{
			TraceOut("CURR_ZWD", 151);
			LeaveRule("CURR_ZWD", 151);
			LeaveRule_CURR_ZWD();
		}
	}
	// $ANTLR end "CURR_ZWD"

	partial void EnterRule_CURR_XBT();
	partial void LeaveRule_CURR_XBT();

	// $ANTLR start "CURR_XBT"
	[GrammarRule("CURR_XBT")]
	private void mCURR_XBT()
	{
		EnterRule_CURR_XBT();
		EnterRule("CURR_XBT", 152);
		TraceIn("CURR_XBT", 152);
		try
		{
			// formula.g:277:18: ( '\\u20bf' )
			DebugEnterAlt(1);
			// formula.g:277:20: '\\u20bf'
			{
			DebugLocation(277, 20);
			Match('\u20BF'); 

			}

		}
		finally
		{
			TraceOut("CURR_XBT", 152);
			LeaveRule("CURR_XBT", 152);
			LeaveRule_CURR_XBT();
		}
	}
	// $ANTLR end "CURR_XBT"

	partial void EnterRule_DIGIT();
	partial void LeaveRule_DIGIT();

	// $ANTLR start "DIGIT"
	[GrammarRule("DIGIT")]
	private void mDIGIT()
	{
		EnterRule_DIGIT();
		EnterRule("DIGIT", 153);
		TraceIn("DIGIT", 153);
		try
		{
			// formula.g:279:15: ( '1' .. '9' ( '0' .. '9' )* )
			DebugEnterAlt(1);
			// formula.g:279:17: '1' .. '9' ( '0' .. '9' )*
			{
			DebugLocation(279, 17);
			MatchRange('1','9'); 
			DebugLocation(279, 26);
			// formula.g:279:26: ( '0' .. '9' )*
			try { DebugEnterSubRule(25);
			while (true)
			{
				int alt25=2;
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if (((LA25_0>='0' && LA25_0<='9')))
				{
					alt25 = 1;
				}


				} finally { DebugExitDecision(25); }
				switch ( alt25 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(279, 26);
					input.Consume();


					}
					break;

				default:
					goto loop25;
				}
			}

			loop25:
				;

			} finally { DebugExitSubRule(25); }


			}

		}
		finally
		{
			TraceOut("DIGIT", 153);
			LeaveRule("DIGIT", 153);
			LeaveRule_DIGIT();
		}
	}
	// $ANTLR end "DIGIT"

	partial void EnterRule_OCTAL_DIGIT();
	partial void LeaveRule_OCTAL_DIGIT();

	// $ANTLR start "OCTAL_DIGIT"
	[GrammarRule("OCTAL_DIGIT")]
	private void mOCTAL_DIGIT()
	{
		EnterRule_OCTAL_DIGIT();
		EnterRule("OCTAL_DIGIT", 154);
		TraceIn("OCTAL_DIGIT", 154);
		try
		{
			// formula.g:280:21: ( '0' ( '0' .. '7' )+ )
			DebugEnterAlt(1);
			// formula.g:280:23: '0' ( '0' .. '7' )+
			{
			DebugLocation(280, 23);
			Match('0'); 
			DebugLocation(280, 27);
			// formula.g:280:27: ( '0' .. '7' )+
			int cnt26=0;
			try { DebugEnterSubRule(26);
			while (true)
			{
				int alt26=2;
				try { DebugEnterDecision(26, false);
				int LA26_0 = input.LA(1);

				if (((LA26_0>='0' && LA26_0<='7')))
				{
					alt26 = 1;
				}


				} finally { DebugExitDecision(26); }
				switch (alt26)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(280, 27);
					input.Consume();


					}
					break;

				default:
					if (cnt26 >= 1)
						goto loop26;

					EarlyExitException eee26 = new EarlyExitException( 26, input );
					DebugRecognitionException(eee26);
					throw eee26;
				}
				cnt26++;
			}
			loop26:
				;

			} finally { DebugExitSubRule(26); }


			}

		}
		finally
		{
			TraceOut("OCTAL_DIGIT", 154);
			LeaveRule("OCTAL_DIGIT", 154);
			LeaveRule_OCTAL_DIGIT();
		}
	}
	// $ANTLR end "OCTAL_DIGIT"

	partial void EnterRule_HEX_DIGIT();
	partial void LeaveRule_HEX_DIGIT();

	// $ANTLR start "HEX_DIGIT"
	[GrammarRule("HEX_DIGIT")]
	private void mHEX_DIGIT()
	{
		EnterRule_HEX_DIGIT();
		EnterRule("HEX_DIGIT", 155);
		TraceIn("HEX_DIGIT", 155);
		try
		{
			// formula.g:281:19: ( '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+ )
			DebugEnterAlt(1);
			// formula.g:281:21: '0x' ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
			{
			DebugLocation(281, 21);
			Match("0x"); 

			DebugLocation(281, 26);
			// formula.g:281:26: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )+
			int cnt27=0;
			try { DebugEnterSubRule(27);
			while (true)
			{
				int alt27=2;
				try { DebugEnterDecision(27, false);
				int LA27_0 = input.LA(1);

				if (((LA27_0>='0' && LA27_0<='9')||(LA27_0>='A' && LA27_0<='F')||(LA27_0>='a' && LA27_0<='f')))
				{
					alt27 = 1;
				}


				} finally { DebugExitDecision(27); }
				switch (alt27)
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:
					{
					DebugLocation(281, 26);
					input.Consume();


					}
					break;

				default:
					if (cnt27 >= 1)
						goto loop27;

					EarlyExitException eee27 = new EarlyExitException( 27, input );
					DebugRecognitionException(eee27);
					throw eee27;
				}
				cnt27++;
			}
			loop27:
				;

			} finally { DebugExitSubRule(27); }


			}

		}
		finally
		{
			TraceOut("HEX_DIGIT", 155);
			LeaveRule("HEX_DIGIT", 155);
			LeaveRule_HEX_DIGIT();
		}
	}
	// $ANTLR end "HEX_DIGIT"

	public override void mTokens()
	{
		// formula.g:1:8: ( INTEGER | FLOAT | CURRENCY | UNIT | EXP | MULT | DIV | PLUS | MINUS | POW | WHITESPACE )
		int alt28=11;
		try { DebugEnterDecision(28, false);
		try
		{
			alt28 = dfa28.Predict(input);
		}
		catch (NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
			throw;
		}
		} finally { DebugExitDecision(28); }
		switch (alt28)
		{
		case 1:
			DebugEnterAlt(1);
			// formula.g:1:10: INTEGER
			{
			DebugLocation(1, 10);
			mINTEGER(); 

			}
			break;
		case 2:
			DebugEnterAlt(2);
			// formula.g:1:18: FLOAT
			{
			DebugLocation(1, 18);
			mFLOAT(); 

			}
			break;
		case 3:
			DebugEnterAlt(3);
			// formula.g:1:24: CURRENCY
			{
			DebugLocation(1, 24);
			mCURRENCY(); 

			}
			break;
		case 4:
			DebugEnterAlt(4);
			// formula.g:1:33: UNIT
			{
			DebugLocation(1, 33);
			mUNIT(); 

			}
			break;
		case 5:
			DebugEnterAlt(5);
			// formula.g:1:38: EXP
			{
			DebugLocation(1, 38);
			mEXP(); 

			}
			break;
		case 6:
			DebugEnterAlt(6);
			// formula.g:1:42: MULT
			{
			DebugLocation(1, 42);
			mMULT(); 

			}
			break;
		case 7:
			DebugEnterAlt(7);
			// formula.g:1:47: DIV
			{
			DebugLocation(1, 47);
			mDIV(); 

			}
			break;
		case 8:
			DebugEnterAlt(8);
			// formula.g:1:51: PLUS
			{
			DebugLocation(1, 51);
			mPLUS(); 

			}
			break;
		case 9:
			DebugEnterAlt(9);
			// formula.g:1:56: MINUS
			{
			DebugLocation(1, 56);
			mMINUS(); 

			}
			break;
		case 10:
			DebugEnterAlt(10);
			// formula.g:1:62: POW
			{
			DebugLocation(1, 62);
			mPOW(); 

			}
			break;
		case 11:
			DebugEnterAlt(11);
			// formula.g:1:66: WHITESPACE
			{
			DebugLocation(1, 66);
			mWHITESPACE(); 

			}
			break;

		}

	}


	#region DFA
	DFA6 dfa6;
	DFA12 dfa12;
	DFA14 dfa14;
	DFA23 dfa23;
	DFA24 dfa24;
	DFA28 dfa28;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa6 = new DFA6(this);
		dfa12 = new DFA12(this);
		dfa14 = new DFA14(this);
		dfa23 = new DFA23(this);
		dfa24 = new DFA24(this);
		dfa28 = new DFA28(this);
	}

	private class DFA6 : DFA
	{
		private const string DFA6_eotS =
			"\x6\xFFFF";
		private const string DFA6_eofS =
			"\x6\xFFFF";
		private const string DFA6_minS =
			"\x2\x2E\x1\xFFFF\x2\x2E\x1\xFFFF";
		private const string DFA6_maxS =
			"\x1\x39\x1\x65\x1\xFFFF\x2\x65\x1\xFFFF";
		private const string DFA6_acceptS =
			"\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2";
		private const string DFA6_specialS =
			"\x6\xFFFF}>";
		private static readonly string[] DFA6_transitionS =
			{
				"\x1\x2\x2\xFFFF\x9\x1",
				"\x1\x2\x1\xFFFF\x1\x4\x9\x3\xB\xFFFF\x1\x5\x1F\xFFFF\x1\x5",
				"",
				"\x1\x2\x1\xFFFF\x1\x4\x9\x3\xB\xFFFF\x1\x5\x1F\xFFFF\x1\x5",
				"\x1\x2\x1\xFFFF\x1\x4\x9\x3\xB\xFFFF\x1\x5\x1F\xFFFF\x1\x5",
				""
			};

		private static readonly short[] DFA6_eot = DFA.UnpackEncodedString(DFA6_eotS);
		private static readonly short[] DFA6_eof = DFA.UnpackEncodedString(DFA6_eofS);
		private static readonly char[] DFA6_min = DFA.UnpackEncodedStringToUnsignedChars(DFA6_minS);
		private static readonly char[] DFA6_max = DFA.UnpackEncodedStringToUnsignedChars(DFA6_maxS);
		private static readonly short[] DFA6_accept = DFA.UnpackEncodedString(DFA6_acceptS);
		private static readonly short[] DFA6_special = DFA.UnpackEncodedString(DFA6_specialS);
		private static readonly short[][] DFA6_transition;

		static DFA6()
		{
			int numStates = DFA6_transitionS.Length;
			DFA6_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA6_transition[i] = DFA.UnpackEncodedString(DFA6_transitionS[i]);
			}
		}

		public DFA6( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 6;
			this.eot = DFA6_eot;
			this.eof = DFA6_eof;
			this.min = DFA6_min;
			this.max = DFA6_max;
			this.accept = DFA6_accept;
			this.special = DFA6_special;
			this.transition = DFA6_transition;
		}

		public override string Description { get { return "40:1: FLOAT : ( ( DIGIT )* '.' ( DIGIT )+ ( EXP )? | ( DIGIT )+ EXP );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA12 : DFA
	{
		private const string DFA12_eotS =
			"\x2E\xFFFF\x1\x51\x21\xFFFF\x1\x51\x1\xFFFF\x1\x51\xD\xFFFF";
		private const string DFA12_eofS =
			"\x60\xFFFF";
		private const string DFA12_minS =
			"\x1\x24\x4\x20\x1\x430\x1\x2E\x1\x0\x1\x4D\x1\x20\x1\x432\x3\x20\x1\x6E"+
			"\x5\x20\x1\x74\x2\x20\x1\x24\x2\x20\x1\x435\x1\x20\x1\x54\x1\x24\x1\x20"+
			"\x1\x73\x1\x20\x1\x142\x1\x65\x1\x443\x1\x438\x1\x54\x1\x20\x1\x54\x2"+
			"\x20\x1\x24\x1\x20\x1\x6B\x2\x2E\x1\xFFFF\x2\x20\x1\x43D\x1\x20\x1\x24"+
			"\x1\x0\x5\x20\x1\x24\x6\x20\x1\x43D\x2\x20\x1\x46\x1\x20\x1\x2E\x1\x20"+
			"\x1\x69\x1\x431\x1\x43D\x2\x24\x2\x20\x1\x2E\x1\xFFFF\x1\x2E\x9\x20\x1"+
			"\x0\x3\x20";
		private const string DFA12_maxS =
			"\x1\xFDFC\x1\x65\x1\x39\x1\x62\x1\x39\x1\x430\x1\x2E\x1\x73\x1\x10D\x1"+
			"\x39\x1\x432\x1\x70\x2\x39\x1\x72\x5\x39\x1\x74\x2\x39\x1\x24\x2\x39"+
			"\x1\x435\x1\x39\x1\x54\x1\x48\x1\x39\x1\x73\x1\x39\x1\x142\x1\x65\x1"+
			"\x443\x1\x438\x1\x54\x1\x39\x1\x54\x2\x39\x1\x24\x1\x39\x1\x6B\x2\x39"+
			"\x1\xFFFF\x2\x39\x1\x43D\x1\x39\x1\x24\x1\x0\x5\x39\x1\x24\x6\x39\x1"+
			"\x43D\x2\x39\x1\x46\x1\x39\x1\x2E\x1\x39\x1\x69\x1\x431\x1\x43D\x2\x24"+
			"\x3\x39\x1\xFFFF\xA\x39\x1\x0\x3\x39";
		private const string DFA12_acceptS =
			"\x2F\xFFFF\x1\x1\x21\xFFFF\x1\x2\xE\xFFFF";
		private const string DFA12_specialS =
			"\x60\xFFFF}>";
		private static readonly string[] DFA12_transitionS =
			{
				"\x1\x3\x1D\xFFFF\x1\x7\x1\x1D\x2\xFFFF\x1\x14\x1\x1F\x2\xFFFF\x1\x17"+
				"\x1\x8\x1\x1\x1\x1C\x1\x25\x1\xFFFF\x1\x9\x1\x13\x1\xB\x1\x20\x1\x27"+
				"\x5\xFFFF\x1\x2A\x10\xFFFF\x1\xE\x1\x22\x3\xFFFF\x1\x6\x9\xFFFF\x1\x21"+
				"\x27\xFFFF\x1\x12\x1\x10\x1\xFFFF\x1\x18\xEC\xFFFF\x1\x4\x281\xFFFF"+
				"\x1\x24\x1F\xFFFF\x1\x1A\x6\xFFFF\x1\xA\x1\x5\x3\xFFFF\x1\x23\x1CA\xFFFF"+
				"\x1\x2\x833\xFFFF\x1\x26\x99B\xFFFF\x1\xC\x8C5\xFFFF\x1\xD\x4\xFFFF"+
				"\x1\x1E\x3\xFFFF\x1\x16\x1\x29\x1\x11\x1\x19\x1\x1B\x2\xFFFF\x1\xF\x2"+
				"\xFFFF\x1\x28\xA\xFFFF\x1\x2B\xDD3C\xFFFF\x1\x15",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E\x2B\xFFFF\x1\x2C",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E\x1B\xFFFF\x1\x31\xC\xFFFF\x1"+
				"\x30",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x32",
				"\x1\x33",
				"\x1\x35\x59\xFFFF\x1\x34\x18\xFFFF\x1\x36",
				"\x1\x37\xBF\xFFFF\x1\x38",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x39",
				"\x1\x2D\x3\xFFFF\x1\x3A\x9\xFFFF\x1\x2F\x2\xFFFF\x9\x2E\xA\xFFFF\x1"+
				"\x3B\x8\xFFFF\x1\x3D\x22\xFFFF\x1\x3C",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x3E\x3\xFFFF\x1\x3F",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x40",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x41",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x42",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x43",
				"\x1\x44\x23\xFFFF\x1\x45",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x46",
				"\x1\x2D\xD\xFFFF\x1\x2F\x1\x47\x1\xFFFF\x9\x2E",
				"\x1\x48",
				"\x1\x49",
				"\x1\x4A",
				"\x1\x4B",
				"\x1\x4C",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x4D",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x4E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x4F",
				"\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2F\x1\xFFFF\x1\x52\x9\x50",
				"",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x53",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x54",
				"\x1\x55",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x56",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x57",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x58",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x59",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x5A",
				"\x1\x5B",
				"\x1\x5C",
				"\x1\x5D",
				"\x1\x5E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2F\x1\xFFFF\x1\x52\x9\x50",
				"",
				"\x1\x2F\x1\xFFFF\x1\x52\x9\x50",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x5F",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E",
				"\x1\x2D\xD\xFFFF\x1\x2F\x2\xFFFF\x9\x2E"
			};

		private static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
		private static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
		private static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
		private static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
		private static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
		private static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
		private static readonly short[][] DFA12_transition;

		static DFA12()
		{
			int numStates = DFA12_transitionS.Length;
			DFA12_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
			}
		}

		public DFA12( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 12;
			this.eot = DFA12_eot;
			this.eof = DFA12_eof;
			this.min = DFA12_min;
			this.max = DFA12_max;
			this.accept = DFA12_accept;
			this.special = DFA12_special;
			this.transition = DFA12_transition;
		}

		public override string Description { get { return "45:1: CURRENCY : ( CURR_SYM ( ' ' )? ( DIGIT )* '.' ( DIGIT )+ | CURR_SYM ( ' ' )? ( DIGIT )+ );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA14 : DFA
	{
		private const string DFA14_eotS =
			"\x6\xFFFF";
		private const string DFA14_eofS =
			"\x6\xFFFF";
		private const string DFA14_minS =
			"\x2\x2E\x1\xFFFF\x2\x2E\x1\xFFFF";
		private const string DFA14_maxS =
			"\x1\x39\x1\x2126\x1\xFFFF\x2\x2126\x1\xFFFF";
		private const string DFA14_acceptS =
			"\x2\xFFFF\x1\x1\x2\xFFFF\x1\x2";
		private const string DFA14_specialS =
			"\x6\xFFFF}>";
		private static readonly string[] DFA14_transitionS =
			{
				"\x1\x2\x2\xFFFF\x9\x1",
				"\x1\x2\x1\xFFFF\x1\x4\x9\x3\x7\xFFFF\x3\x5\x1\xFFFF\x1\x2\x3\x5\x1"+
				"\xFFFF\x2\x5\x2\xFFFF\x1\x5\x1\xFFFF\x1\x5\x2\xFFFF\x2\x5\x1\xFFFF\x2"+
				"\x5\xB\xFFFF\x1\x5\x1\xFFFF\x1\x2\x5\xFFFF\x3\x5\x1\xFFFF\x1\x5\x2\xFFFF"+
				"\x2\x5\x3C\xFFFF\x1\x5\x2075\xFFFF\x1\x5",
				"",
				"\x1\x2\x1\xFFFF\x1\x4\x9\x3\x7\xFFFF\x3\x5\x1\xFFFF\x1\x2\x3\x5\x1"+
				"\xFFFF\x2\x5\x2\xFFFF\x1\x5\x1\xFFFF\x1\x5\x2\xFFFF\x2\x5\x1\xFFFF\x2"+
				"\x5\xB\xFFFF\x1\x5\x1\xFFFF\x1\x2\x5\xFFFF\x3\x5\x1\xFFFF\x1\x5\x2\xFFFF"+
				"\x2\x5\x3C\xFFFF\x1\x5\x2075\xFFFF\x1\x5",
				"\x1\x2\x1\xFFFF\x1\x4\x9\x3\x7\xFFFF\x3\x5\x1\xFFFF\x1\x2\x3\x5\x1"+
				"\xFFFF\x2\x5\x2\xFFFF\x1\x5\x1\xFFFF\x1\x5\x2\xFFFF\x2\x5\x1\xFFFF\x2"+
				"\x5\xB\xFFFF\x1\x5\x1\xFFFF\x1\x2\x5\xFFFF\x3\x5\x1\xFFFF\x1\x5\x2\xFFFF"+
				"\x2\x5\x3C\xFFFF\x1\x5\x2075\xFFFF\x1\x5",
				""
			};

		private static readonly short[] DFA14_eot = DFA.UnpackEncodedString(DFA14_eotS);
		private static readonly short[] DFA14_eof = DFA.UnpackEncodedString(DFA14_eofS);
		private static readonly char[] DFA14_min = DFA.UnpackEncodedStringToUnsignedChars(DFA14_minS);
		private static readonly char[] DFA14_max = DFA.UnpackEncodedStringToUnsignedChars(DFA14_maxS);
		private static readonly short[] DFA14_accept = DFA.UnpackEncodedString(DFA14_acceptS);
		private static readonly short[] DFA14_special = DFA.UnpackEncodedString(DFA14_specialS);
		private static readonly short[][] DFA14_transition;

		static DFA14()
		{
			int numStates = DFA14_transitionS.Length;
			DFA14_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA14_transition[i] = DFA.UnpackEncodedString(DFA14_transitionS[i]);
			}
		}

		public DFA14( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 14;
			this.eot = DFA14_eot;
			this.eof = DFA14_eof;
			this.min = DFA14_min;
			this.max = DFA14_max;
			this.accept = DFA14_accept;
			this.special = DFA14_special;
			this.transition = DFA14_transition;
		}

		public override string Description { get { return "50:1: UNIT : ( FLOAT ( ' ' )? SI_UNIT | INTEGER SI_UNIT );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA23 : DFA
	{
		private const string DFA23_eotS =
			"\x1\xFFFF\x1\x1E\x1\xFFFF\x1\x22\x1\x24\x3\xFFFF\x1\x29\x1\x2C\x1\xFFFF"+
			"\x1\x2F\x1\x32\x1\x34\x1\x36\x1\x38\x2\xFFFF\x1\x3A\x8\xFFFF\x1\x43\x3"+
			"\xFFFF\x1\x46\x5\xFFFF\x1\x4A\x7\xFFFF\x1\x4D\xF\xFFFF\x1\x58\x1\x5A"+
			"\x1\xFFFF\x1\x5C\x3\xFFFF\x1\x5F\x2\xFFFF\x1\x62\x1\x65\x2\xFFFF\x1\x68"+
			"\x2E\xFFFF\x1\x86\xC\xFFFF";
		private const string DFA23_eofS =
			"\x87\xFFFF";
		private const string DFA23_minS =
			"\x1\x41\x1\x2F\x1\x61\x1\x72\x1\x2F\x1\xFFFF\x1\x64\x1\x61\x2\x2F\x1"+
			"\x61\x5\x2F\x2\xFFFF\x1\x76\x2\xFFFF\x1\x6D\x1\xFFFF\x1\x79\x1\x6C\x1"+
			"\xFFFF\x1\x2D\x1\x2F\x1\x73\x2\xFFFF\x1\x2F\x1\x74\x2\xFFFF\x1\x6D\x1"+
			"\xFFFF\x1\x2F\x1\x64\x6\xFFFF\x1\xB7\x1\x28\x2\xFFFF\x1\x28\x1\xFFFF"+
			"\x1\x6B\x9\xFFFF\x2\x2F\x1\xFFFF\x1\x2F\x3\xFFFF\x1\x5E\x1\x6D\x1\xFFFF"+
			"\x1\x2F\x1\x5E\x1\x6D\x1\xFFFF\x1\x2F\x3\xFFFF\x1\x6B\x1\xFFFF\x2\x5E"+
			"\x1\x6D\x1\xFFFF\x1\x5E\x3\xFFFF\x1\x6D\x6\xFFFF\x1\x5E\x1\x6D\x4\xFFFF"+
			"\x1\x5E\x1\x73\x8\xFFFF\x1\x5E\x1\xFFFF\x1\x32\x1\xFFFF\x1\x5E\x2\xFFFF"+
			"\x1\x5E\x2\xFFFF\x1\x5E\xC\xFFFF";
		private const string DFA23_maxS =
			"\x1\x2126\x1\x207B\x1\x67\x1\x72\x1\x2F\x1\xFFFF\x1\x64\x1\x61\x1\x7A"+
			"\x1\xB7\x1\x61\x1\x2F\x1\x62\x3\x2F\x2\xFFFF\x1\x76\x2\xFFFF\x1\x78\x1"+
			"\xFFFF\x1\x79\x1\x6C\x1\xFFFF\x1\x33\x1\x2F\x1\x73\x2\xFFFF\x1\x2F\x1"+
			"\x74\x2\xFFFF\x1\x6D\x1\xFFFF\x1\x2F\x1\x64\x6\xFFFF\x1\xB7\x1\x6D\x2"+
			"\xFFFF\x1\x73\x1\xFFFF\x1\x6D\x9\xFFFF\x2\x2F\x1\xFFFF\x1\x2F\x3\xFFFF"+
			"\x1\xB2\x1\x6D\x1\xFFFF\x1\x2F\x1\xB2\x1\x6D\x1\xFFFF\x1\x2F\x3\xFFFF"+
			"\x1\x6D\x1\xFFFF\x1\xB3\x1\xB2\x1\x6D\x1\xFFFF\x1\xB3\x3\xFFFF\x1\x6D"+
			"\x6\xFFFF\x1\xB3\x1\x6D\x4\xFFFF\x1\xB2\x1\x73\x8\xFFFF\x1\xB7\x1\xFFFF"+
			"\x1\x33\x1\xFFFF\x1\xB3\x2\xFFFF\x1\xB3\x2\xFFFF\x1\xB2\xC\xFFFF";
		private const string DFA23_acceptS =
			"\x5\xFFFF\x1\x5\xA\xFFFF\x1\x26\x1\x27\x1\xFFFF\x1\x2A\x1\x2C\x1\xFFFF"+
			"\x1\x2F\x2\xFFFF\x1\x8\x3\xFFFF\x1\xF\x1\x1\x2\xFFFF\x1\x1D\x1\x3\x1"+
			"\xFFFF\x1\x4\x2\xFFFF\x1\x1E\x1\x47\x1\x2B\x1\x34\x1\x35\x1\x1F\x2\xFFFF"+
			"\x1\x21\x1\x29\x1\xFFFF\x1\x22\x1\xFFFF\x1\x23\x1\x41\x1\x24\x1\x46\x1"+
			"\x25\x1\x31\x1\x28\x1\x2D\x1\x2E\x2\xFFFF\x1\x9\x1\xFFFF\x1\x10\x1\x13"+
			"\x1\xA\x2\xFFFF\x1\x2\x3\xFFFF\x1\x7\x1\xFFFF\x1\x33\x1\x20\x1\x3B\x1"+
			"\xFFFF\x1\x3D\x3\xFFFF\x1\x4C\x1\xFFFF\x1\x4A\x1\x4B\x1\x30\x1\xFFFF"+
			"\x1\x6\x1\x14\x1\xB\x1\xD\x1\xE\x1\xC\x2\xFFFF\x1\x32\x1\x15\x1\x16\x1"+
			"\x17\x2\xFFFF\x1\x1C\x1\x3C\x1\x49\x1\x3F\x1\x40\x1\x48\x1\x39\x1\x3A"+
			"\x1\xFFFF\x1\x42\x1\xFFFF\x1\x44\x1\xFFFF\x1\x11\x1\x12\x1\xFFFF\x1\x1A"+
			"\x1\x1B\x1\xFFFF\x1\x3E\x1\x4D\x1\x4E\x1\x43\x1\x45\x1\x18\x1\x19\x1"+
			"\x4F\x1\x50\x1\x37\x1\x38\x1\x36";
		private const string DFA23_specialS =
			"\x87\xFFFF}>";
		private static readonly string[] DFA23_transitionS =
			{
				"\x1\x4\x1\x16\x1\xD\x2\xFFFF\x1\xF\x1\x17\x1\x8\x1\xFFFF\x1\xB\x1\x5"+
				"\x2\xFFFF\x1\x9\x1\xFFFF\x1\xA\x2\xFFFF\x1\x12\x1\x13\x1\xFFFF\x1\xE"+
				"\x1\xC\xB\xFFFF\x1\x6\x7\xFFFF\x1\x2\x1\x15\x1\x1\x1\xFFFF\x1\x11\x2"+
				"\xFFFF\x1\x7\x1\x3\x3C\xFFFF\x1\x14\x2075\xFFFF\x1\x10",
				"\x1\x1C\x2E\xFFFF\x1\x1A\x10\xFFFF\x1\x18\x42\xFFFF\x1\x19\x1\x1B\x1FC7"+
				"\xFFFF\x1\x1D",
				"\x1\x20\x5\xFFFF\x1\x1F",
				"\x1\x21",
				"\x1\x23",
				"",
				"\x1\x25",
				"\x1\x26",
				"\x1\x28\x4A\xFFFF\x1\x27",
				"\x1\x2B\x87\xFFFF\x1\x2A",
				"\x1\x2D",
				"\x1\x2E",
				"\x1\x31\x32\xFFFF\x1\x30",
				"\x1\x33",
				"\x1\x35",
				"\x1\x37",
				"",
				"",
				"\x1\x39",
				"",
				"",
				"\x1\x3B\xA\xFFFF\x1\x3C",
				"",
				"\x1\x3D",
				"\x1\x3E",
				"",
				"\x1\x41\x4\xFFFF\x1\x3F\x1\x40",
				"\x1\x42",
				"\x1\x44",
				"",
				"",
				"\x1\x45",
				"\x1\x47",
				"",
				"",
				"\x1\x48",
				"",
				"\x1\x49",
				"\x1\x4B",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x4C",
				"\x1\x4F\x22\xFFFF\x1\x4E\x1F\xFFFF\x1\x50\x1\xFFFF\x1\x51",
				"",
				"",
				"\x1\x53\x44\xFFFF\x1\x52\x5\xFFFF\x1\x54",
				"",
				"\x1\x56\x1\xFFFF\x1\x55",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x57",
				"\x1\x59",
				"",
				"\x1\x5B",
				"",
				"",
				"",
				"\x1\x5E\x53\xFFFF\x1\x5D",
				"\x1\x60",
				"",
				"\x1\x61",
				"\x1\x64\x53\xFFFF\x1\x63",
				"\x1\x66",
				"",
				"\x1\x67",
				"",
				"",
				"",
				"\x1\x69\x1\xFFFF\x1\x6A",
				"",
				"\x1\x6C\x10\xFFFF\x1\x6D\x43\xFFFF\x1\x6B",
				"\x1\x6F\x53\xFFFF\x1\x6E",
				"\x1\x70",
				"",
				"\x1\x72\x53\xFFFF\x1\x73\x1\x71",
				"",
				"",
				"",
				"\x1\x74",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x76\x54\xFFFF\x1\x75",
				"\x1\x77",
				"",
				"",
				"",
				"",
				"\x1\x79\x53\xFFFF\x1\x78",
				"\x1\x7A",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x7D\x53\xFFFF\x1\x7C\x4\xFFFF\x1\x7B",
				"",
				"\x1\x7F\x1\x7E",
				"",
				"\x1\x81\x54\xFFFF\x1\x80",
				"",
				"",
				"\x1\x83\x54\xFFFF\x1\x82",
				"",
				"",
				"\x1\x85\x53\xFFFF\x1\x84",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA23_eot = DFA.UnpackEncodedString(DFA23_eotS);
		private static readonly short[] DFA23_eof = DFA.UnpackEncodedString(DFA23_eofS);
		private static readonly char[] DFA23_min = DFA.UnpackEncodedStringToUnsignedChars(DFA23_minS);
		private static readonly char[] DFA23_max = DFA.UnpackEncodedStringToUnsignedChars(DFA23_maxS);
		private static readonly short[] DFA23_accept = DFA.UnpackEncodedString(DFA23_acceptS);
		private static readonly short[] DFA23_special = DFA.UnpackEncodedString(DFA23_specialS);
		private static readonly short[][] DFA23_transition;

		static DFA23()
		{
			int numStates = DFA23_transitionS.Length;
			DFA23_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA23_transition[i] = DFA.UnpackEncodedString(DFA23_transitionS[i]);
			}
		}

		public DFA23( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 23;
			this.eot = DFA23_eot;
			this.eof = DFA23_eof;
			this.min = DFA23_min;
			this.max = DFA23_max;
			this.accept = DFA23_accept;
			this.special = DFA23_special;
			this.transition = DFA23_transition;
		}

		public override string Description { get { return "78:20: ( SI_METER | SI_KG | SI_SEC | SI_AMP | SI_KELVIN | SI_MOLE | SI_CANDELA | SI_SQ_METER_1 | SI_SQ_METER_2 | SI_CU_METER_1 | SI_CU_METER_2 | SI_MPS | SI_MPS_SQ_1 | SI_MPS_SQ_2 | SI_REC_METER_1 | SI_REC_METER_2 | SI_KG_CU_METER_1 | SI_KG_CU_METER_2 | SI_CU_METER_KG_1 | SI_CU_METER_KG_2 | SI_AMP_SQ_METER_1 | SI_AMP_SQ_METER_2 | SI_AMP_METER | SI_MOL_CU_METER_1 | SI_MOL_CU_METER_2 | SI_CANDELA_SQ_METER_1 | SI_CANDELA_SQ_METER_2 | SI_RADIAN | SI_SOLID_ANGLE | SI_HERTZ | SI_NEWTON | SI_PASCAL | SI_JOULE | SI_WATT | SI_COULOMB | SI_VOLT | SI_FARAD | SI_OHM_1 | SI_OHM_2 | SI_SIEMENS | SI_WEBER | SI_TESLA | SI_HENRY | SI_CELCIUS | SI_LUMEN | SI_LUX | SI_BECQUEREL | SI_GRAY | SI_SIEVERT | SI_KATAL | SI_PASCAL_SEC | SI_NEWTON_METER | SI_NEWTON_PER_METER | SI_RADIAN_PER_SEC | SI_RADIAN_PER_SEC_SQ_1 | SI_RADIAN_PER_SEC_SQ_2 | SI_WATT_PER_METER_SQ_1 | SI_WATT_PER_METER_SQ_2 | SI_JOULE_PER_KELVIN | SI_JOULE_PER_KG_KELVIN | SI_JOULE_PER_KG | SI_WATT_PER_METER_KELVIN | SI_JOULE_PER_CU_METER_1 | SI_JOULE_PER_CU_METER_2 | SI_VOLT_PER_METER | SI_COULOMB_PER_CU_METER_1 | SI_COULOMB_PER_CU_METER_2 | SI_COULOMB_PER_SQ_METER_1 | SI_COULOMB_PER_SQ_METER_2 | SI_FARAD_PER_METER | SI_HENRY_PER_METER | SI_JOULE_PER_MOLE | SI_JOULE_PER_MOLE_KELVIN | SI_COULOMB_PER_KG | SI_GRAY_PER_SEC | SI_WATT_PER_STERADIAN | SI_WATT_PER_SQ_METER_STERADIAN_1 | SI_WATT_PER_SQ_METER_STERADIAN_2 | SI_KATAL_PER_CU_METER_1 | SI_KATAL_PER_CU_METER_2 )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA24 : DFA
	{
		private const string DFA24_eotS =
			"\x1\xFFFF\x1\x2D\x1\xFFFF\x1\x30\x7\xFFFF\x1\x3A\x14\xFFFF\x1\x40\x20"+
			"\xFFFF";
		private const string DFA24_eofS =
			"\x41\xFFFF";
		private const string DFA24_minS =
			"\x1\x24\x1\x65\x1\xFFFF\x1\x55\x3\xFFFF\x1\x0\x1\x4D\x2\xFFFF\x1\x24"+
			"\x2\xFFFF\x1\x6E\xE\xFFFF\x1\x24\x2\xFFFF\x1\x2F\x20\xFFFF";
		private const string DFA24_maxS =
			"\x1\xFDFC\x1\x65\x1\xFFFF\x1\x62\x3\xFFFF\x1\x73\x1\x10D\x2\xFFFF\x1"+
			"\x70\x2\xFFFF\x1\x72\xE\xFFFF\x1\x48\x2\xFFFF\x1\x2F\x20\xFFFF";
		private const string DFA24_acceptS =
			"\x2\xFFFF\x1\x2\x1\xFFFF\x1\x4\x1\x5\x1\x6\x2\xFFFF\x1\xA\x1\xB\x1\xFFFF"+
			"\x1\xD\x1\xE\x1\xFFFF\x1\x10\x1\x14\x1\x15\x1\x16\x1\x17\x1\x19\x1\x1B"+
			"\x1\x1C\x1\x1D\x1\x1E\x1\x1F\x1\x20\x1\x22\x1\x23\x1\xFFFF\x1\x25\x1"+
			"\x27\x1\xFFFF\x1\x29\x1\x2A\x1\x2B\x1\x2C\x1\x30\x1\x31\x1\x32\x1\x33"+
			"\x1\x36\x1\x37\x1\x38\x1\x1\x1\x18\x1\x8\x1\x34\x1\x3\x1\x7\x1\x26\x1"+
			"\x35\x1\x9\x1\x11\x1\xC\x1\x13\x1\x1A\x1\x21\x1\x2E\x1\xF\x1\x12\x1\x24"+
			"\x1\x2F\x1\x28\x1\x2D";
		private const string DFA24_specialS =
			"\x41\xFFFF}>";
		private static readonly string[] DFA24_transitionS =
			{
				"\x1\x3\x1D\xFFFF\x1\x7\x1\x1D\x2\xFFFF\x1\x14\x1\x1F\x2\xFFFF\x1\x17"+
				"\x1\x8\x1\x1\x1\x1C\x1\x25\x1\xFFFF\x1\x9\x1\x13\x1\xB\x1\x20\x1\x27"+
				"\x5\xFFFF\x1\x2A\x10\xFFFF\x1\xE\x1\x22\x3\xFFFF\x1\x6\x9\xFFFF\x1\x21"+
				"\x27\xFFFF\x1\x12\x1\x10\x1\xFFFF\x1\x18\xEC\xFFFF\x1\x4\x281\xFFFF"+
				"\x1\x24\x1F\xFFFF\x1\x1A\x6\xFFFF\x1\xA\x1\x5\x3\xFFFF\x1\x23\x1CA\xFFFF"+
				"\x1\x2\x833\xFFFF\x1\x26\x99B\xFFFF\x1\xC\x8C5\xFFFF\x1\xD\x4\xFFFF"+
				"\x1\x1E\x3\xFFFF\x1\x16\x1\x29\x1\x11\x1\x19\x1\x1B\x2\xFFFF\x1\xF\x2"+
				"\xFFFF\x1\x28\xA\xFFFF\x1\x2B\xDD3C\xFFFF\x1\x15",
				"\x1\x2C",
				"",
				"\x1\x2F\xC\xFFFF\x1\x2E",
				"",
				"",
				"",
				"\x1\x32\x59\xFFFF\x1\x31\x18\xFFFF\x1\x33",
				"\x1\x34\xBF\xFFFF\x1\x35",
				"",
				"",
				"\x1\x36\x1F\xFFFF\x1\x37\x8\xFFFF\x1\x39\x22\xFFFF\x1\x38",
				"",
				"",
				"\x1\x3B\x3\xFFFF\x1\x3C",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x3D\x23\xFFFF\x1\x3E",
				"",
				"",
				"\x1\x3F",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				""
			};

		private static readonly short[] DFA24_eot = DFA.UnpackEncodedString(DFA24_eotS);
		private static readonly short[] DFA24_eof = DFA.UnpackEncodedString(DFA24_eofS);
		private static readonly char[] DFA24_min = DFA.UnpackEncodedStringToUnsignedChars(DFA24_minS);
		private static readonly char[] DFA24_max = DFA.UnpackEncodedStringToUnsignedChars(DFA24_maxS);
		private static readonly short[] DFA24_accept = DFA.UnpackEncodedString(DFA24_acceptS);
		private static readonly short[] DFA24_special = DFA.UnpackEncodedString(DFA24_specialS);
		private static readonly short[][] DFA24_transition;

		static DFA24()
		{
			int numStates = DFA24_transitionS.Length;
			DFA24_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA24_transition[i] = DFA.UnpackEncodedString(DFA24_transitionS[i]);
			}
		}

		public DFA24( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 24;
			this.eot = DFA24_eot;
			this.eof = DFA24_eof;
			this.min = DFA24_min;
			this.max = DFA24_max;
			this.accept = DFA24_accept;
			this.special = DFA24_special;
			this.transition = DFA24_transition;
		}

		public override string Description { get { return "189:9: ( CURR_ALL | CURR_AFN | CURR_USD | CURR_AWG | CURR_AZN | CURR_BYR | CURR_BZD | CURR_BOB | CURR_BAM | CURR_BWP | CURR_BGN | CURR_BRL | CURR_KHR | CURR_CRC | CURR_HRK | CURR_CUP | CURR_CZK | CURR_DKK | CURR_DOP | CURR_GBP | CURR_EUR | CURR_GHS | CURR_GTQ | CURR_HNL | CURR_HUF | CURR_IDR | CURR_IRR | CURR_ILS | CURR_JMD | CURR_JPY | CURR_LAK | CURR_MKD | CURR_MYR | CURR_MNT | CURR_MZN | CURR_NIO | CURR_NGN | CURR_PAB | CURR_PYG | CURR_PEN | CURR_PLN | CURR_RON | CURR_RUB | CURR_RSD | CURR_SOS | CURR_ZAR | CURR_CHF | CURR_TWD | CURR_THB | CURR_TTD | CURR_UAH | CURR_UYU | CURR_VEF | CURR_VND | CURR_ZWD | CURR_XBT )"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private class DFA28 : DFA
	{
		private const string DFA28_eotS =
			"\x1\xFFFF\x1\x15\x1\xE\x1\xFFFF\x9\x12\x7\xFFFF\x1\x15\x1\xFFFF\x1\x15"+
			"\x3\xFFFF\x1\x23\x5\x12\x1\xFFFF\x2\x23\x2\xFFFF\x1\x23\x4\x12\x2\x23"+
			"\x1\xFFFF\x3\x23";
		private const string DFA28_eofS =
			"\x30\xFFFF";
		private const string DFA28_minS =
			"\x1\x9\x1\x2E\x1\x31\x1\xFFFF\x2\x20\x1\x430\x1\x432\x1\x20\x1\x435\x1"+
			"\x443\x1\x438\x1\x20\x7\xFFFF\x1\x2E\x1\xFFFF\x1\x2E\x1\x31\x1\x2B\x1"+
			"\xFFFF\x1\x20\x1\x43D\x1\x20\x1\x43D\x1\x431\x1\x43D\x1\x31\x2\x20\x1"+
			"\xFFFF\x1\x2B\x4\x20\x1\x0\x2\x20\x1\x31\x3\x20";
		private const string DFA28_maxS =
			"\x1\xFDFC\x1\x2126\x1\x39\x1\xFFFF\x2\x39\x1\x430\x1\x432\x1\x39\x1\x435"+
			"\x1\x443\x1\x438\x1\x39\x7\xFFFF\x1\x2126\x1\xFFFF\x1\x2126\x2\x39\x1"+
			"\xFFFF\x1\x2126\x1\x43D\x1\x39\x1\x43D\x1\x431\x1\x43D\x1\x39\x2\x2126"+
			"\x1\xFFFF\x1\x39\x1\x2126\x3\x39\x1\x0\x2\x2126\x1\x39\x3\x2126";
		private const string DFA28_acceptS =
			"\x3\xFFFF\x1\x3\x9\xFFFF\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA\x1\xB\x1"+
			"\xFFFF\x1\x1\x3\xFFFF\x1\x4\x9\xFFFF\x1\x2\xC\xFFFF";
		private const string DFA28_specialS =
			"\x30\xFFFF}>";
		private static readonly string[] DFA28_transitionS =
			{
				"\x2\x13\x1\xFFFF\x2\x13\x12\xFFFF\x1\x13\x3\xFFFF\x1\x3\x5\xFFFF\x1"+
				"\xE\x1\x10\x1\xFFFF\x1\x11\x1\x2\x1\xF\x1\xFFFF\x9\x1\x8\xFFFF\x2\x3"+
				"\x1\xFFFF\x1\xD\x2\x3\x2\xFFFF\x5\x3\x1\xFFFF\x5\x3\x5\xFFFF\x1\x3\x3"+
				"\xFFFF\x1\x12\x6\xFFFF\x1\xD\x5\xFFFF\x2\x3\x3\xFFFF\x1\x3\x9\xFFFF"+
				"\x1\x3\x27\xFFFF\x2\x3\x1\xFFFF\x1\x3\x11\xFFFF\x1\xE\x1\xFFFF\xD9\x12"+
				"\x1\x5\x281\x12\x1\xB\x1F\x12\x1\x9\x6\x12\x1\x7\x1\x6\x3\x12\x1\xA"+
				"\x1CA\x12\x1\x4\x833\x12\x1\xC\x99B\x12\x1\x8\x89E\x12\x27\xFFFF\x1"+
				"\x3\x4\xFFFF\x1\x3\x3\xFFFF\x5\x3\x2\xFFFF\x1\x3\x2\xFFFF\x1\x3\xA\xFFFF"+
				"\x1\x3\xDD3C\xFFFF\x1\x3",
				"\x1\x17\x1\xFFFF\x1\x16\x9\x14\x7\xFFFF\x3\x19\x1\xFFFF\x1\x18\x3\x19"+
				"\x1\xFFFF\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1"+
				"\xFFFF\x2\x19\xB\xFFFF\x1\x19\x1\xFFFF\x1\x18\x5\xFFFF\x3\x19\x1\xFFFF"+
				"\x1\x19\x2\xFFFF\x2\x19\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"\x9\x1A",
				"",
				"\x1\x3\xD\xFFFF\x1\x3\x2\xFFFF\x9\x3",
				"\x1\x3\xD\xFFFF\x1\x3\x2\xFFFF\x9\x3",
				"\x1\x1B",
				"\x1\x1C",
				"\x1\x3\xD\xFFFF\x1\x3\x2\xFFFF\x9\x3",
				"\x1\x1D",
				"\x1\x1E",
				"\x1\x1F",
				"\x1\x3\xD\xFFFF\x1\x3\x2\xFFFF\x9\x3",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x17\x1\xFFFF\x1\x16\x9\x14\x7\xFFFF\x3\x19\x1\xFFFF\x1\x18\x3\x19"+
				"\x1\xFFFF\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1"+
				"\xFFFF\x2\x19\xB\xFFFF\x1\x19\x1\xFFFF\x1\x18\x5\xFFFF\x3\x19\x1\xFFFF"+
				"\x1\x19\x2\xFFFF\x2\x19\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"",
				"\x1\x17\x1\xFFFF\x1\x16\x9\x14\x7\xFFFF\x3\x19\x1\xFFFF\x1\x18\x3\x19"+
				"\x1\xFFFF\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1"+
				"\xFFFF\x2\x19\xB\xFFFF\x1\x19\x1\xFFFF\x1\x18\x5\xFFFF\x3\x19\x1\xFFFF"+
				"\x1\x19\x2\xFFFF\x2\x19\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"\x9\x1A",
				"\x1\x20\x1\xFFFF\x1\x20\x3\xFFFF\x9\x21",
				"",
				"\x1\x19\xF\xFFFF\x1\x25\x9\x22\x7\xFFFF\x3\x19\x1\xFFFF\x1\x24\x3\x19"+
				"\x1\xFFFF\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1"+
				"\xFFFF\x2\x19\xB\xFFFF\x1\x19\x1\xFFFF\x1\x24\x5\xFFFF\x3\x19\x1\xFFFF"+
				"\x1\x19\x2\xFFFF\x2\x19\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"\x1\x26",
				"\x1\x3\xD\xFFFF\x1\x3\x2\xFFFF\x9\x3",
				"\x1\x27",
				"\x1\x28",
				"\x1\x29",
				"\x9\x21",
				"\x1\x19\xF\xFFFF\x1\x2B\x9\x2A\x7\xFFFF\x3\x19\x2\xFFFF\x3\x19\x1\xFFFF"+
				"\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1\xFFFF\x2"+
				"\x19\xB\xFFFF\x1\x19\x7\xFFFF\x3\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19"+
				"\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"\x1\x19\xF\xFFFF\x1\x25\x9\x22\x7\xFFFF\x3\x19\x1\xFFFF\x1\x24\x3\x19"+
				"\x1\xFFFF\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1"+
				"\xFFFF\x2\x19\xB\xFFFF\x1\x19\x1\xFFFF\x1\x24\x5\xFFFF\x3\x19\x1\xFFFF"+
				"\x1\x19\x2\xFFFF\x2\x19\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"",
				"\x1\x2C\x1\xFFFF\x1\x2C\x3\xFFFF\x9\x2D",
				"\x1\x19\xF\xFFFF\x1\x25\x9\x22\x7\xFFFF\x3\x19\x1\xFFFF\x1\x24\x3\x19"+
				"\x1\xFFFF\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1"+
				"\xFFFF\x2\x19\xB\xFFFF\x1\x19\x1\xFFFF\x1\x24\x5\xFFFF\x3\x19\x1\xFFFF"+
				"\x1\x19\x2\xFFFF\x2\x19\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"\x1\x3\xD\xFFFF\x1\x3\x2\xFFFF\x9\x3",
				"\x1\x3\xD\xFFFF\x1\x3\x2\xFFFF\x9\x3",
				"\x1\x3\xD\xFFFF\x1\x3\x2\xFFFF\x9\x3",
				"\x1\x3",
				"\x1\x19\xF\xFFFF\x1\x2B\x9\x2A\x7\xFFFF\x3\x19\x2\xFFFF\x3\x19\x1\xFFFF"+
				"\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1\xFFFF\x2"+
				"\x19\xB\xFFFF\x1\x19\x7\xFFFF\x3\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19"+
				"\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"\x1\x19\xF\xFFFF\x1\x2B\x9\x2A\x7\xFFFF\x3\x19\x2\xFFFF\x3\x19\x1\xFFFF"+
				"\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1\xFFFF\x2"+
				"\x19\xB\xFFFF\x1\x19\x7\xFFFF\x3\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19"+
				"\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"\x9\x2D",
				"\x1\x19\xF\xFFFF\x1\x2F\x9\x2E\x7\xFFFF\x3\x19\x2\xFFFF\x3\x19\x1\xFFFF"+
				"\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1\xFFFF\x2"+
				"\x19\xB\xFFFF\x1\x19\x7\xFFFF\x3\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19"+
				"\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"\x1\x19\xF\xFFFF\x1\x2F\x9\x2E\x7\xFFFF\x3\x19\x2\xFFFF\x3\x19\x1\xFFFF"+
				"\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1\xFFFF\x2"+
				"\x19\xB\xFFFF\x1\x19\x7\xFFFF\x3\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19"+
				"\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19",
				"\x1\x19\xF\xFFFF\x1\x2F\x9\x2E\x7\xFFFF\x3\x19\x2\xFFFF\x3\x19\x1\xFFFF"+
				"\x2\x19\x2\xFFFF\x1\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19\x1\xFFFF\x2"+
				"\x19\xB\xFFFF\x1\x19\x7\xFFFF\x3\x19\x1\xFFFF\x1\x19\x2\xFFFF\x2\x19"+
				"\x3C\xFFFF\x1\x19\x2075\xFFFF\x1\x19"
			};

		private static readonly short[] DFA28_eot = DFA.UnpackEncodedString(DFA28_eotS);
		private static readonly short[] DFA28_eof = DFA.UnpackEncodedString(DFA28_eofS);
		private static readonly char[] DFA28_min = DFA.UnpackEncodedStringToUnsignedChars(DFA28_minS);
		private static readonly char[] DFA28_max = DFA.UnpackEncodedStringToUnsignedChars(DFA28_maxS);
		private static readonly short[] DFA28_accept = DFA.UnpackEncodedString(DFA28_acceptS);
		private static readonly short[] DFA28_special = DFA.UnpackEncodedString(DFA28_specialS);
		private static readonly short[][] DFA28_transition;

		static DFA28()
		{
			int numStates = DFA28_transitionS.Length;
			DFA28_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA28_transition[i] = DFA.UnpackEncodedString(DFA28_transitionS[i]);
			}
		}

		public DFA28( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 28;
			this.eot = DFA28_eot;
			this.eof = DFA28_eof;
			this.min = DFA28_min;
			this.max = DFA28_max;
			this.accept = DFA28_accept;
			this.special = DFA28_special;
			this.transition = DFA28_transition;
		}

		public override string Description { get { return "1:1: Tokens : ( INTEGER | FLOAT | CURRENCY | UNIT | EXP | MULT | DIV | PLUS | MINUS | POW | WHITESPACE );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

 
	#endregion

}

} // namespace Palantir.Numeric.Parser
