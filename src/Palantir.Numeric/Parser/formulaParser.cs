//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 formula.g 2016-04-14 05:25:36

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace Palantir.Numeric.Parser
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class formulaParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "DIGIT", "DIV", "EXP", "FLOAT", "HEX_DIGIT", "INTEGER", "MINUS", "MULT", "OCTAL_DIGIT", "PLUS", "WHITESPACE"
	};
	public const int EOF=-1;
	public const int DIGIT=4;
	public const int DIV=5;
	public const int EXP=6;
	public const int FLOAT=7;
	public const int HEX_DIGIT=8;
	public const int INTEGER=9;
	public const int MINUS=10;
	public const int MULT=11;
	public const int OCTAL_DIGIT=12;
	public const int PLUS=13;
	public const int WHITESPACE=14;

	public formulaParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public formulaParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return formulaParser.tokenNames; } }
	public override string GrammarFileName { get { return "formula.g"; } }




	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// formula.g:35:1: expr : term ( ( PLUS | MINUS ) term )* ;
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<CommonTree, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 1);
		TraceIn("expr", 1);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set2 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> term1 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> term3 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set2_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(35, 43);
		try
		{
			// formula.g:35:9: ( term ( ( PLUS | MINUS ) term )* )
			DebugEnterAlt(1);
			// formula.g:35:11: term ( ( PLUS | MINUS ) term )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(35, 11);
			PushFollow(Follow._term_in_expr146);
			term1=term();
			PopFollow();

			adaptor.AddChild(root_0, term1.Tree);
			DebugLocation(35, 16);
			// formula.g:35:16: ( ( PLUS | MINUS ) term )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==MINUS||LA1_0==PLUS))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:35:18: ( PLUS | MINUS ) term
					{
					DebugLocation(35, 18);

					set2=(IToken)input.LT(1);
					if (input.LA(1)==MINUS||input.LA(1)==PLUS)
					{
						input.Consume();
						adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set2));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(35, 36);
					PushFollow(Follow._term_in_expr161);
					term3=term();
					PopFollow();

					adaptor.AddChild(root_0, term3.Tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 1);
			LeaveRule("expr", 1);
			LeaveRule_expr();
		}
		DebugLocation(35, 43);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// formula.g:37:1: term : factor ( ( MULT | DIV ) factor )* ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<CommonTree, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 2);
		TraceIn("term", 2);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken set5 = default(IToken);
		AstParserRuleReturnScope<CommonTree, IToken> factor4 = default(AstParserRuleReturnScope<CommonTree, IToken>);
		AstParserRuleReturnScope<CommonTree, IToken> factor6 = default(AstParserRuleReturnScope<CommonTree, IToken>);

		CommonTree set5_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(37, 44);
		try
		{
			// formula.g:37:9: ( factor ( ( MULT | DIV ) factor )* )
			DebugEnterAlt(1);
			// formula.g:37:11: factor ( ( MULT | DIV ) factor )*
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(37, 11);
			PushFollow(Follow._factor_in_term176);
			factor4=factor();
			PopFollow();

			adaptor.AddChild(root_0, factor4.Tree);
			DebugLocation(37, 18);
			// formula.g:37:18: ( ( MULT | DIV ) factor )*
			try { DebugEnterSubRule(2);
			while (true)
			{
				int alt2=2;
				try { DebugEnterDecision(2, false);
				int LA2_0 = input.LA(1);

				if ((LA2_0==DIV||LA2_0==MULT))
				{
					alt2 = 1;
				}


				} finally { DebugExitDecision(2); }
				switch ( alt2 )
				{
				case 1:
					DebugEnterAlt(1);
					// formula.g:37:20: ( MULT | DIV ) factor
					{
					DebugLocation(37, 20);

					set5=(IToken)input.LT(1);
					if (input.LA(1)==DIV||input.LA(1)==MULT)
					{
						input.Consume();
						adaptor.AddChild(root_0, (CommonTree)adaptor.Create(set5));
						state.errorRecovery=false;
					}
					else
					{
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(37, 35);
					PushFollow(Follow._factor_in_term190);
					factor6=factor();
					PopFollow();

					adaptor.AddChild(root_0, factor6.Tree);

					}
					break;

				default:
					goto loop2;
				}
			}

			loop2:
				;

			} finally { DebugExitSubRule(2); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 2);
			LeaveRule("term", 2);
			LeaveRule_term();
		}
		DebugLocation(37, 44);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_factor();
	partial void LeaveRule_factor();

	// $ANTLR start "factor"
	// formula.g:39:1: factor : INTEGER ;
	[GrammarRule("factor")]
	private AstParserRuleReturnScope<CommonTree, IToken> factor()
	{
		EnterRule_factor();
		EnterRule("factor", 3);
		TraceIn("factor", 3);
		AstParserRuleReturnScope<CommonTree, IToken> retval = new AstParserRuleReturnScope<CommonTree, IToken>();
		retval.Start = (IToken)input.LT(1);

		CommonTree root_0 = default(CommonTree);

		IToken INTEGER7 = default(IToken);

		CommonTree INTEGER7_tree = default(CommonTree);
		try { DebugEnterRule(GrammarFileName, "factor");
		DebugLocation(39, 18);
		try
		{
			// formula.g:39:9: ( INTEGER )
			DebugEnterAlt(1);
			// formula.g:39:11: INTEGER
			{
			root_0 = (CommonTree)adaptor.Nil();

			DebugLocation(39, 11);
			INTEGER7=(IToken)Match(input,INTEGER,Follow._INTEGER_in_factor204); 
			INTEGER7_tree = (CommonTree)adaptor.Create(INTEGER7);
			adaptor.AddChild(root_0, INTEGER7_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (CommonTree)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (CommonTree)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("factor", 3);
			LeaveRule("factor", 3);
			LeaveRule_factor();
		}
		DebugLocation(39, 18);
		} finally { DebugExitRule(GrammarFileName, "factor"); }
		return retval;

	}
	// $ANTLR end "factor"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _term_in_expr146 = new BitSet(new ulong[]{0x2402UL});
		public static readonly BitSet _set_in_expr150 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _term_in_expr161 = new BitSet(new ulong[]{0x2402UL});
		public static readonly BitSet _factor_in_term176 = new BitSet(new ulong[]{0x822UL});
		public static readonly BitSet _set_in_term180 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _factor_in_term190 = new BitSet(new ulong[]{0x822UL});
		public static readonly BitSet _INTEGER_in_factor204 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace Palantir.Numeric.Parser
